<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rippled: Negative UNL Engineering Spec</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">rippled
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Negative UNL Engineering Spec </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md65"></a>
The Problem Statement</h1>
<p >The moment-to-moment health of the XRP Ledger network depends on the health and connectivity of a small number of computers (nodes). The most important nodes are validators, specifically ones listed on the unique node list (UNL). Ripple publishes a recommended UNL that most network nodes use to determine which peers in the network are trusted. Although most validators use the same list, they are not required to. The XRP Ledger network progresses to the next ledger when enough validators reach agreement (above the minimum quorum of 80%) about what transactions to include in the next ledger.</p>
<p >As an example, if there are 10 validators on the UNL, at least 8 validators have to agree with the latest ledger for it to become validated. But what if enough of those validators are offline to drop the network below the 80% quorum? The XRP Ledger network favors safety/correctness over advancing the ledger. Which means if enough validators are offline, the network will not be able to validate ledgers.</p>
<p >Unfortunately validators can go offline at any time for many different reasons. Power outages, network connectivity issues, and hardware failures are just a few scenarios where a validator would appear "offline". Given that most of these events are temporary, it would make sense to temporarily remove that validator from the UNL. But the UNL is updated infrequently and not every node uses the same UNL. So instead of removing the unreliable validator from the Ripple recommended UNL, we can create a second negative UNL which is stored directly on the ledger (so the entire network has the same view). This will help the network see which validators are <b>currently</b> unreliable, and adjust their quorum calculation accordingly.</p>
<p ><em>Improving the liveness of the network is the main motivation for the negative UNL.</em></p>
<h2><a class="anchor" id="autotoc_md66"></a>
Targeted Faults</h2>
<p >In order to determine which validators are unreliable, we need clearly define what kind of faults to measure and analyze. We want to deal with the faults we frequently observe in the production network. Hence we will only monitor for validators that do not reliably respond to network messages or send out validations disagreeing with the locally generated validations. We will not target other byzantine faults.</p>
<p >To track whether or not a validator is responding to the network, we could monitor them with a “heartbeat” protocol. Instead of creating a new heartbeat protocol, we can leverage some existing protocol messages to mimic the heartbeat. We picked validation messages because validators should send one and only one validation message per ledger. In addition, we only count the validation messages that agree with the local node's validations.</p>
<p >With the negative UNL, the network could keep making forward progress safely even if the number of remaining validators gets to 60%. Say we have a network with 10 validators on the UNL and everything is operating correctly. The quorum required for this network would be 8 (80% of 10). When validators fail, the quorum required would be as low as 6 (60% of 10), which is the absolute <em><b>minimum quorum</b></em>. We need the absolute minimum quorum to be strictly greater than 50% of the original UNL so that there cannot be two partitions of well-behaved nodes headed in different directions. We arbitrarily choose 60% as the minimum quorum to give a margin of safety.</p>
<p >Consider these events in the absence of negative UNL:</p><ol type="1">
<li>1:00pm - validator1 fails, votes vs. quorum: 9 &gt;= 8, we have quorum</li>
</ol>
<ol type="1">
<li>3:00pm - validator2 fails, votes vs. quorum: 8 &gt;= 8, we have quorum</li>
</ol>
<ol type="1">
<li>5:00pm - validator3 fails, votes vs. quorum: 7 &lt; 8, we don’t have quorum<ul>
<li><b>network cannot validate new ledgers with 3 failed validators</b></li>
</ul>
</li>
</ol>
<p >We're below 80% agreement, so new ledgers cannot be validated. This is how the XRP Ledger operates today, but if the negative UNL was enabled, the events would happen as follows. (Please note that the events below are from a simplified version of our protocol.)</p>
<ol type="1">
<li>1:00pm - validator1 fails, votes vs. quorum: 9 &gt;= 8, we have quorum</li>
</ol>
<ol type="1">
<li>1:40pm - network adds validator1 to negative UNL, quorum changes to ceil(9 * 0.8), or 8</li>
</ol>
<ol type="1">
<li>3:00pm - validator2 fails, votes vs. quorum: 8 &gt;= 8, we have quorum</li>
</ol>
<ol type="1">
<li>3:40pm - network adds validator2 to negative UNL, quorum changes to ceil(8 * 0.8), or 7</li>
</ol>
<ol type="1">
<li>5:00pm - validator3 fails, votes vs. quorum: 7 &gt;= 7, we have quorum</li>
</ol>
<ol type="1">
<li>5:40pm - network adds validator3 to negative UNL, quorum changes to ceil(7 * 0.8), or 6</li>
</ol>
<ol type="1">
<li>7:00pm - validator4 fails, votes vs. quorum: 6 &gt;= 6, we have quorum<ul>
<li><b>network can still validate new ledgers with 4 failed validators</b></li>
</ul>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md67"></a>
External Interactions</h1>
<h2><a class="anchor" id="autotoc_md68"></a>
Message Format Changes</h2>
<p >This proposal will:</p><ol type="1">
<li>add a new pseudo-transaction type</li>
</ol>
<ol type="1">
<li>add the negative UNL to the ledger data structure.</li>
</ol>
<p >Any tools or systems that rely on the format of this data will have to be updated.</p>
<h2><a class="anchor" id="autotoc_md69"></a>
Amendment</h2>
<p >This feature <b>will</b> need an amendment to activate.</p>
<h1><a class="anchor" id="autotoc_md70"></a>
Design</h1>
<p >This section discusses the following topics about the Negative UNL design:</p>
<ul>
<li>Negative UNL protocol overview</li>
<li>Validator reliability measurement</li>
<li>Format Changes</li>
<li>Negative UNL maintenance</li>
<li>Quorum size calculation</li>
<li>Filter validation messages</li>
<li>High level sequence diagram of code changes</li>
</ul>
<h2><a class="anchor" id="autotoc_md71"></a>
Negative UNL Protocol Overview</h2>
<p >Every ledger stores a list of zero or more unreliable validators. Updates to the list must be approved by the validators using the consensus mechanism that validators use to agree on the set of transactions. The list is used only when checking if a ledger is fully validated. If a validator V is in the list, nodes with V in their UNL adjust the quorum and V’s validation message is not counted when verifying if a ledger is fully validated. V’s flow of messages and network interactions, however, will remain the same.</p>
<p >We define the <em><b>effective UNL** = original UNL - negative UNL*, and the ***effective quorum</b></em> as the quorum of the <em>effective UNL</em>. And we set <em>effective quorum = Ceiling(80% * effective UNL)</em>.</p>
<h2><a class="anchor" id="autotoc_md72"></a>
Validator Reliability Measurement</h2>
<p >A node only measures the reliability of validators on its own UNL, and only proposes based on local observations. There are many metrics that a node can measure about its validators, but we have chosen ledger validation messages. This is because every validator shall send one and only one signed validation message per ledger. This keeps the measurement simple and removes timing/clock-sync issues. A node will measure the percentage of agreeing validation messages (<em>PAV</em>) received from each validator on the node's UNL. Note that the node will only count the validation messages that agree with its own validations.</p>
<p >We define the <b>PAV</b> as the **P**ercentage of **A**greed **V**alidation messages received for the last N ledgers, where N = 256 by default.</p>
<p >When the PAV drops below the <em><b>low-water mark</b></em>, the validator is considered unreliable, and is a candidate to be disabled by being added to the negative UNL. A validator must have a PAV higher than the <em><b>high-water mark</b></em> to be re-enabled. The validator is re-enabled by removing it from the negative UNL. In the implementation, we plan to set the low-water mark as 50% and the high-water mark as 80%.</p>
<h2><a class="anchor" id="autotoc_md73"></a>
Format Changes</h2>
<p >The negative UNL component in a ledger contains three fields.</p><ul>
<li><em><b>NegativeUNL</b></em>: The current negative UNL, a list of unreliable validators.</li>
<li><em><b>ToDisable</b></em>: The validator to be added to the negative UNL on the next flag ledger.</li>
<li><em><b>ToReEnable</b></em>: The validator to be removed from the negative UNL on the next flag ledger.</li>
</ul>
<p >All three fields are optional. When the <em>ToReEnable</em> field exists, the <em>NegativeUNL</em> field cannot be empty.</p>
<p >A new pseudo-transaction, <em><b>UNLModify</b></em>, is added. It has three fields</p><ul>
<li><em><b>Disabling</b></em>: A flag indicating whether the modification is to disable or to re-enable a validator.</li>
<li><em><b>Seq</b></em>: The ledger sequence number.</li>
<li><em><b>Validator</b></em>: The validator to be disabled or re-enabled.</li>
</ul>
<p >There would be at most one <em>disable</em> <code>UNLModify</code> and one <em>re-enable</em> <code>UNLModify</code> transaction per flag ledger. The full machinery is described further on.</p>
<h2><a class="anchor" id="autotoc_md74"></a>
Negative UNL Maintenance</h2>
<p >The negative UNL can only be modified on the flag ledgers. If a validator's reliability status changes, it takes two flag ledgers to modify the negative UNL. Let's see an example of the algorithm:</p>
<ul>
<li>Ledger seq = 100: A validator V goes offline.</li>
<li>Ledger seq = 256: This is a flag ledger, and V's reliability measurement <em>PAV</em> is lower than the low-water mark. Other validators add <code>UNLModify</code> pseudo-transactions <code>{true, 256, V}</code> to the transaction set which goes through the consensus. Then the pseudo-transaction is applied to the negative UNL ledger component by setting <code>ToDisable = V</code>.</li>
<li>Ledger seq = 257 ~ 511: The negative UNL ledger component is copied from the parent ledger.</li>
<li>Ledger seq=512: This is a flag ledger, and the negative UNL is updated <code>NegativeUNL = NegativeUNL + ToDisable</code>.</li>
</ul>
<p >The negative UNL may have up to <code>MaxNegativeListed = floor(original UNL * 25%)</code> validators. The 25% is because of 75% * 80% = 60%, where 75% = 100% - 25%, 80% is the quorum of the effective UNL, and 60% is the absolute minimum quorum of the original UNL. Adding more than 25% validators to the negative UNL does not improve the liveness of the network, because adding more validators to the negative UNL cannot lower the effective quorum.</p>
<p >The following is the detailed algorithm:</p>
<ul>
<li><b>If</b> the ledger seq = x is a flag ledger<ol type="1">
<li>Compute <code>NegativeUNL = NegativeUNL + ToDisable - ToReEnable</code> if they exist in the parent ledger <pre class="fragment">1. Try to find a candidate to disable if `sizeof NegativeUNL &lt; MaxNegativeListed`

1. Find a validator V that has a *PAV* lower than the low-water
mark, but is not in `NegativeUNL`.

1. If two or more are found, their public keys are XORed with the hash
of the parent ledger and the one with the lowest XOR result is chosen.

1. If V is found, create a `UNLModify` pseudo-transaction
`TxDisableValidator = {true, x, V}`
</pre></li>
</ol>
<ol type="1">
<li>Try to find a candidate to re-enable if <code>sizeof NegativeUNL &gt; 0</code>:<ol type="a">
<li>Find a validator U that is in <code>NegativeUNL</code> and has a <em>PAV</em> higher than the high-water mark.</li>
</ol>
<ol type="a">
<li>If U is not found, try to find one in <code>NegativeUNL</code> but not in the local <em>UNL</em>.</li>
</ol>
<ol type="a">
<li>If two or more are found, their public keys are XORed with the hash of the parent ledger and the one with the lowest XOR result is chosen.</li>
</ol>
<ol type="a">
<li>If U is found, create a <code>UNLModify</code> pseudo-transaction <code>TxReEnableValidator = {false, x, U}</code></li>
</ol>
</li>
</ol>
<ol type="1">
<li>If any <code>UNLModify</code> pseudo-transactions are created, add them to the transaction set. The transaction set goes through the consensus algorithm.</li>
</ol>
<ol type="1">
<li>If have enough support, the <code>UNLModify</code> pseudo-transactions remain in the transaction set agreed by the validators. Then the pseudo-transactions are applied to the ledger: <pre class="fragment">1. If have `TxDisableValidator`, set `ToDisable=TxDisableValidator.V`.
Else clear `ToDisable`.

1. If have `TxReEnableValidator`, set
`ToReEnable=TxReEnableValidator.U`. Else clear `ToReEnable`.
</pre></li>
</ol>
</li>
<li><b>Else</b> (not a flag ledger)<ol type="1">
<li>Copy the negative UNL ledger component from the parent ledger</li>
</ol>
</li>
</ul>
<p >The negative UNL is stored on each ledger because we don't know when a validator may reconnect to the network. If the negative UNL was stored only on every flag ledger, then a new validator would have to wait until it acquires the latest flag ledger to know the negative UNL. So any new ledgers created that are not flag ledgers copy the negative UNL from the parent ledger.</p>
<p >Note that when we have a validator to disable and a validator to re-enable at the same flag ledger, we create two separate <code>UNLModify</code> pseudo-transactions. We want either one or the other or both to make it into the ledger on their own merits.</p>
<p >Readers may have noticed that we defined several rules of creating the <code>UNLModify</code> pseudo-transactions but did not describe how to enforce the rules. The rules are actually enforced by the existing consensus algorithm. Unless enough validators propose the same pseudo-transaction it will not be included in the transaction set of the ledger.</p>
<h2><a class="anchor" id="autotoc_md75"></a>
Quorum Size Calculation</h2>
<p >The effective quorum is 80% of the effective UNL. Note that because at most 25% of the original UNL can be on the negative UNL, the quorum should not be lower than the absolute minimum quorum (i.e. 60%) of the original UNL. However, considering that different nodes may have different UNLs, to be safe we compute <code>quorum = Ceiling(max(60% * original UNL, 80% * effective UNL))</code>.</p>
<h2><a class="anchor" id="autotoc_md76"></a>
Filter Validation Messages</h2>
<p >If a validator V is in the negative UNL, it still participates in consensus sessions in the same way, i.e. V still follows the protocol and publishes proposal and validation messages. The messages from V are still stored the same way by everyone, used to calculate the new PAV for V, and could be used in future consensus sessions if needed. However V's ledger validation message is not counted when checking if the ledger is fully validated.</p>
<h2><a class="anchor" id="autotoc_md77"></a>
High Level Sequence Diagram of Code Changes</h2>
<p >The diagram below is the sequence of one round of consensus. Classes and components with non-trivial changes are colored green.</p>
<ul>
<li>The <code>ValidatorList</code> class is modified to compute the quorum of the effective UNL.</li>
<li>The <code>Validations</code> class provides an interface for querying the validation messages from trusted validators.</li>
<li>The <code>ConsensusAdaptor</code> component:<ul>
<li>The <code>RCLConsensus::Adaptor</code> class is modified for creating <code>UNLModify</code> Pseudo-Transactions.</li>
<li>The <code>Change</code> class is modified for applying <code>UNLModify</code> Pseudo-Transactions.</li>
<li>The <code>Ledger</code> class is modified for creating and adjusting the negative UNL ledger component.</li>
<li>The <code>LedgerMaster</code> class is modified for filtering out validation messages from negative UNL validators when verifying if a ledger is fully validated.</li>
</ul>
</li>
</ul>
<p ><img src="./negativeUNL_highLevel_sequence.png?raw=true" alt="Sequence diagram" title="Negative UNL Changes" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md78"></a>
Roads Not Taken</h1>
<h2><a class="anchor" id="autotoc_md79"></a>
Use a Mechanism Like Fee Voting to Process UNLModify Pseudo-Transactions</h2>
<p >The previous version of the negative UNL specification used the same mechanism as the <a href="https://xrpl.org/fee-voting.html#voting-process.">fee voting</a> for creating the negative UNL, and used the negative UNL as soon as the ledger was fully validated. However the timing of fully validation can differ among nodes, so different negative UNLs could be used, resulting in different effective UNLs and different quorums for the same ledger. As a result, the network's safety is impacted.</p>
<p >This updated version does not impact safety though operates a bit more slowly. The negative UNL modifications in the <em>UNLModify</em> pseudo-transaction approved by the consensus will take effect at the next flag ledger. The extra time of the 256 ledgers should be enough for nodes to be in sync of the negative UNL modifications.</p>
<h2><a class="anchor" id="autotoc_md80"></a>
Use an Expiration Approach to Re-enable Validators</h2>
<p >After a validator disabled by the negative UNL becomes reliable, other validators explicitly vote for re-enabling it. An alternative approach to re-enable a validator is the expiration approach, which was considered in the previous version of the specification. In the expiration approach, every entry in the negative UNL has a fixed expiration time. One flag ledger interval was chosen as the expiration interval. Once expired, the other validators must continue voting to keep the unreliable validator on the negative UNL. The advantage of this approach is its simplicity. But it has a requirement. The negative UNL protocol must be able to vote multiple unreliable validators to be disabled at the same flag ledger. In this version of the specification, however, only one unreliable validator can be disabled at a flag ledger. So the expiration approach cannot be simply applied.</p>
<h2><a class="anchor" id="autotoc_md81"></a>
Validator Reliability Measurement and Flag Ledger Frequency</h2>
<p >If the ledger time is about 4.5 seconds and the low-water mark is 50%, then in the worst case, it takes 48 minutes *((0.5 * 256 + 256 + 256) * 4.5 / 60 = 48)* to put an offline validator on the negative UNL. We considered lowering the flag ledger frequency so that the negative UNL can be more responsive. We also considered decoupling the reliability measurement and flag ledger frequency to be more flexible. In practice, however, their benefits are not clear.</p>
<h1><a class="anchor" id="autotoc_md82"></a>
New Attack Vectors</h1>
<p >A group of malicious validators may try to frame a reliable validator and put it on the negative UNL. But they cannot succeed. Because:</p>
<ol type="1">
<li>A reliable validator sends a signed validation message every ledger. A sufficient peer-to-peer network will propagate the validation messages to other validators. The validators will decide if another validator is reliable or not only by its local observation of the validation messages received. So an honest validator’s vote on another validator’s reliability is accurate.</li>
</ol>
<ol type="1">
<li>Given the votes are accurate, and one vote per validator, an honest validator will not create a UNLModify transaction of a reliable validator.</li>
</ol>
<ol type="1">
<li>A validator can be added to a negative UNL only through a UNLModify transaction.</li>
</ol>
<p >Assuming the group of malicious validators is less than the quorum, they cannot frame a reliable validator.</p>
<h1><a class="anchor" id="autotoc_md83"></a>
Summary</h1>
<p >The bullet points below briefly summarize the current proposal:</p>
<ul>
<li>The motivation of the negative UNL is to improve the liveness of the network.</li>
<li>The targeted faults are the ones frequently observed in the production network.</li>
<li>Validators propose negative UNL candidates based on their local measurements.</li>
<li>The absolute minimum quorum is 60% of the original UNL.</li>
<li>The format of the ledger is changed, and a new <em>UNLModify</em> pseudo-transaction is added. Any tools or systems that rely on the format of these data will have to be updated.</li>
<li>The negative UNL can only be modified on the flag ledgers.</li>
<li>At most one validator can be added to the negative UNL at a flag ledger.</li>
<li>At most one validator can be removed from the negative UNL at a flag ledger.</li>
<li>If a validator's reliability status changes, it takes two flag ledgers to modify the negative UNL.</li>
<li>The quorum is the larger of 80% of the effective UNL and 60% of the original UNL.</li>
<li>If a validator is on the negative UNL, its validation messages are ignored when the local node verifies if a ledger is fully validated.</li>
</ul>
<h1><a class="anchor" id="autotoc_md84"></a>
FAQ</h1>
<h2><a class="anchor" id="autotoc_md85"></a>
Question: What are UNLs?</h2>
<p >Quote from the <a href="https://xrpl.org/technical-faq.html">Technical FAQ</a>: "They are
the lists of transaction validators a given participant believes will not
conspire to defraud them."</p>
<h2><a class="anchor" id="autotoc_md86"></a>
Question: How does the negative UNL proposal affect network liveness?</h2>
<p >The network can make forward progress when more than a quorum of the trusted validators agree with the progress. The lower the quorum size is, the easier for the network to progress. If the quorum is too low, however, the network is not safe because nodes may have different results. So the quorum size used in the consensus protocol is a balance between the safety and the liveness of the network. The negative UNL reduces the size of the effective UNL, resulting in a lower quorum size while keeping the network safe.</p>
<h3>Question: How does a validator get into the negative UNL? How is a validator removed from the negative UNL? </h3>
<p >A validator’s reliability is measured by other validators. If a validator becomes unreliable, at a flag ledger, other validators propose <em>UNLModify</em> pseudo-transactions which vote the validator to add to the negative UNL during the consensus session. If agreed, the validator is added to the negative UNL at the next flag ledger. The mechanism of removing a validator from the negative UNL is the same.</p>
<h2><a class="anchor" id="autotoc_md87"></a>
Question: Given a negative UNL, what happens if the UNL changes?</h2>
<p >Answer: Let’s consider the cases:</p>
<ol type="1">
<li><p class="startli">A validator is added to the UNL, and it is already in the negative UNL. This case could happen when not all the nodes have the same UNL. Note that the negative UNL on the ledger lists unreliable nodes that are not necessarily the validators for everyone.</p>
<p class="startli">In this case, the liveness is affected negatively. Because the minimum quorum could be larger but the usable validators are not increased.</p>
</li>
</ol>
<ol type="1">
<li><p class="startli">A validator is removed from the UNL, and it is in the negative UNL.</p>
<p class="startli">In this case, the liveness is affected positively. Because the quorum could be smaller but the usable validators are not reduced.</p>
</li>
</ol>
<ol type="1">
<li>A validator is added to the UNL, and it is not in the negative UNL.</li>
</ol>
<ol type="1">
<li><p class="startli">A validator is removed from the UNL, and it is not in the negative UNL.</p>
<p class="startli">Case 3 and 4 are not affected by the negative UNL protocol.</p>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md88"></a>
Question: Can we simply lower the quorum to 60% without the negative UNL?</h2>
<p >Answer: No, because the negative UNL approach is safer.</p>
<p >First let’s compare the two approaches intuitively, (1) the <em>negative UNL</em> approach, and (2) <em>lower quorum</em>: simply lowering the quorum from 80% to 60% without the negative UNL. The negative UNL approach uses consensus to come up with a list of unreliable validators, which are then removed from the effective UNL temporarily. With this approach, the list of unreliable validators is agreed to by a quorum of validators and will be used by every node in the network to adjust its UNL. The quorum is always 80% of the effective UNL. The lower quorum approach is a tradeoff between safety and liveness and against our principle of preferring safety over liveness. Note that different validators don't have to agree on which validation sources they are ignoring.</p>
<p >Next we compare the two approaches quantitatively with examples, and apply Theorem 8 of <a href="https://arxiv.org/abs/1802.07242">Analysis of the XRP Ledger Consensus Protocol</a> paper:</p>
<p >*XRP LCP guarantees fork safety if **O<sub>i,j</sub> &gt; n<sub>j</sub> / 2 + n<sub>i</sub> − q<sub>i</sub> + t<sub>i,j</sub>** for every pair of nodes P<sub>i</sub>, P<sub>j</sub>,*</p>
<p >where *O<sub>i,j</sub>* is the overlapping requirement, n<sub>j</sub> and n<sub>i</sub> are UNL sizes, q<sub>i</sub> is the quorum size of P<sub>i</sub>, *t<sub>i,j</sub> = min(t<sub>i</sub>, t<sub>j</sub>, O<sub>i,j</sub>)*, and t<sub>i</sub> and t<sub>j</sub> are the number of faults can be tolerated by P<sub>i</sub> and P<sub>j</sub>.</p>
<p >We denote *UNL<sub>i</sub>* as *P<sub>i</sub>'s UNL*, and *|UNL<sub>i</sub>|* as the size of *P<sub>i</sub>'s UNL*.</p>
<p >Assuming *|UNL<sub>i</sub>| = |UNL<sub>j</sub>|*, let's consider the following three cases:</p>
<ol type="1">
<li>With 80% quorum and 20% faults, *O<sub>i,j</sub> &gt; 100% / 2 + 100% - 80% + 20% = 90%*. I.e. fork safety requires &gt; 90% UNL overlaps. This is one of the results in the analysis paper.</li>
</ol>
<ol type="1">
<li>If the quorum is 60%, the relationship between the overlapping requirement and the faults that can be tolerated is *O<sub>i,j</sub> &gt; 90% + t<sub>i,j</sub>*. Under the same overlapping condition (i.e. 90%), to guarantee the fork safety, the network cannot tolerate any faults. So under the same overlapping condition, if the quorum is simply lowered, the network can tolerate fewer faults.</li>
</ol>
<ol type="1">
<li><p class="startli">With the negative UNL approach, we want to argue that the inequation *O<sub>i,j</sub> &gt; n<sub>j</sub> / 2 + n<sub>i</sub> − q<sub>i</sub> + t<sub>i,j</sub>* is always true to guarantee fork safety, while the negative UNL protocol runs, i.e. the effective quorum is lowered without weakening the network's fault tolerance. To make the discussion easier, we rewrite the inequation as *O<sub>i,j</sub> &gt; n<sub>j</sub> / 2 + (n<sub>i</sub> − q<sub>i</sub>) + min(t<sub>i</sub>, t<sub>j</sub>)*, where O<sub>i,j</sub> is dropped from the definition of t<sub>i,j</sub> because *O<sub>i,j</sub> &gt; min(t<sub>i</sub>, t<sub>j</sub>)* always holds under the parameters we will use. Assuming a validator V is added to the negative UNL, now let's consider the 4 cases:</p><ol type="a">
<li><p class="startli">V is not on UNL<sub>i</sub> nor UNL<sub>j</sub></p>
<p class="startli">The inequation holds because none of the variables change.</p>
</li>
</ol>
<ol type="a">
<li><p class="startli">V is on UNL<sub>i</sub> but not on UNL<sub>j</sub></p>
<p class="startli">The value of *(n<sub>i</sub> − q<sub>i</sub>)* is smaller. The value of *min(t<sub>i</sub>, t<sub>j</sub>)* could be smaller too. Other variables do not change. Overall, the left side of the inequation does not change, but the right side is smaller. So the inequation holds.</p>
</li>
</ol>
<ol type="a">
<li><p class="startli">V is not on UNL<sub>i</sub> but on UNL<sub>j</sub></p>
<p class="startli">The value of *n<sub>j</sub> / 2* is smaller. The value of *min(t<sub>i</sub>, t<sub>j</sub>)* could be smaller too. Other variables do not change. Overall, the left side of the inequation does not change, but the right side is smaller. So the inequation holds.</p>
</li>
</ol>
<ol type="a">
<li><p class="startli">V is on both UNL<sub>i</sub> and UNL<sub>j</sub></p>
<p class="startli">The value of *O<sub>i,j</sub>* is reduced by 1. The values of *n<sub>j</sub> / 2*, *(n<sub>i</sub> − q<sub>i</sub>)*, and *min(t<sub>i</sub>, t<sub>j</sub>)* are reduced by 0.5, 0.2, and 1 respectively. The right side is reduced by 1.7. Overall, the left side of the inequation is reduced by 1, and the right side is reduced by 1.7. So the inequation holds.</p>
</li>
</ol>
<p class="startli">The inequation holds for all the cases. So with the negative UNL approach, the network's fork safety is preserved, while the quorum is lowered that increases the network's liveness.</p>
</li>
</ol>
<h3>Question: We have observed that occasionally a validator wanders off on its own chain. How is this case handled by the negative UNL algorithm? </h3>
<p >Answer: The case that a validator wanders off on its own chain can be measured with the validations agreement. Because the validations by this validator must be different from other validators' validations of the same sequence numbers. When there are enough disagreed validations, other validators will vote this validator onto the negative UNL.</p>
<p >In general by measuring the agreement of validations, we also measured the "sanity". If two validators have too many disagreements, one of them could be insane. When enough validators think a validator is insane, that validator is put on the negative UNL.</p>
<h3>Question: Why would there be at most one disable UNLModify and one re-enable UNLModify transaction per flag ledger? </h3>
<p >Answer: It is a design choice so that the effective UNL does not change too quickly. A typical targeted scenario is several validators go offline slowly during a long weekend. The current design can handle this kind of cases well without changing the effective UNL too quickly.</p>
<h1><a class="anchor" id="autotoc_md89"></a>
Appendix</h1>
<h2><a class="anchor" id="autotoc_md90"></a>
Confidence Test</h2>
<p >We will use two test networks, a single machine test network with multiple IP addresses and the QE test network with multiple machines. The single machine network will be used to test all the test cases and to debug. The QE network will be used after that. We want to see the test cases still pass with real network delay. A test case specifies:</p>
<ol type="1">
<li>a UNL with different number of validators for different test cases,</li>
</ol>
<ol type="1">
<li>a network with zero or more non-validator nodes,</li>
</ol>
<ol type="1">
<li>a sequence of validator reliability change events (by killing/restarting nodes, or by running modified rippled that does not send all validation messages),</li>
</ol>
<ol type="1">
<li>the correct outcomes.</li>
</ol>
<p >For all the test cases, the correct outcomes are verified by examining logs. We will grep the log to see if the correct negative UNLs are generated, and whether or not the network is making progress when it should be. The ripdtop tool will be helpful for monitoring validators' states and ledger progress. Some of the timing parameters of rippled will be changed to have faster ledger time. Most if not all test cases do not need client transactions.</p>
<p >For example, the test cases for the prototype:</p><ol type="1">
<li>A 10-validator UNL.</li>
</ol>
<ol type="1">
<li>The network does not have other nodes.</li>
</ol>
<ol type="1">
<li>The validators will be started from the genesis. Once they start to produce ledgers, we kill five validators, one every flag ledger interval. Then we will restart them one by one.</li>
</ol>
<ol type="1">
<li>A sequence of events (or the lack of events) such as a killed validator is added to the negative UNL.</li>
</ol>
<h3><a class="anchor" id="autotoc_md91"></a>
Roads Not Taken: Test with Extended CSF</h3>
<p >We considered testing with the current unit test framework, specifically the <a href="https://github.com/ripple/rippled/blob/develop/src/test/csf/README.md">Consensus Simulation Framework</a> (CSF). However, the CSF currently can only test the generic consensus algorithm as in the paper: <a href="https://arxiv.org/abs/1802.07242">Analysis of the XRP Ledger Consensus Protocol</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
