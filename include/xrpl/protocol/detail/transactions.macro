//------------------------------------------------------------------------------
/*
    This file is part of rippled: https://github.com/ripple/rippled
    Copyright (c) 2024 Ripple Labs Inc.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose  with  or without fee is hereby granted, provided that the above
    copyright notice and this permission notice appear in all copies.

    THE  SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH  REGARD  TO  THIS  SOFTWARE  INCLUDING  ALL  IMPLIED  WARRANTIES  OF
    MERCHANTABILITY  AND  FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY  SPECIAL ,  DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER  RESULTING  FROM  LOSS  OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION  OF  CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/
//==============================================================================

#if !defined(TRANSACTION)
#error "undefined macro: TRANSACTION"
#endif

/**
 * TRANSACTION(tag, value, name, privileges, fields)
 *
 * You must define a transactor class in the `ripple` namespace named `name`,
 * and include its header alongside the TRANSACTOR definition using this
 * format:
 * #if TRANSACTION_INCLUDE
 * #   include <xrpld/app/tx/detail/HEADER.h>
 * #endif
 *
 * The `privileges` parameter of the TRANSACTION macro is a bitfield
 * defining which operations the transaction can perform.
 *
 * The values are only used in InvariantCheck.cpp
 * Valid values are
    noPriv - The transaction can not do any of the enumerated operations
    createAcct - The transaction can create a new ACCOUNT_ROOT object.
    createPseudoAcct - The transaction can create a pseudo account,
        which implies createAcct
    mustDeleteAcct - The transaction must delete an ACCOUNT_ROOT object
    mayDeleteAcct - The transaction may delete an ACCOUNT_ROOT object,
        but does not have to
    overrideFreeze - The transaction can override some freeze rules
    changeNFTCounts - The transaction can mint or burn an NFT
    createMPTIssuance - The transaction can create a new MPT issuance
    destroyMPTIssuance - The transaction can destroy an MPT issuance
    mustAuthorizeMPT - The transaction MUST create or delete an MPT
        object (except by issuer)
    mayAuthorizeMPT - The transaction MAY create or delete an MPT
        object (except by issuer)
 */

/** This transaction type executes a payment. */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/Payment.h>
#endif
TRANSACTION(ttPAYMENT, 0, Payment, createAcct, ({
    {sfDestination, soeREQUIRED},
    {sfAmount, soeREQUIRED, soeMPTSupported},
    {sfSendMax, soeOPTIONAL, soeMPTSupported},
    {sfPaths, soeDEFAULT},
    {sfInvoiceID, soeOPTIONAL},
    {sfDestinationTag, soeOPTIONAL},
    {sfDeliverMin, soeOPTIONAL, soeMPTSupported},
    {sfCredentialIDs, soeOPTIONAL},
}))

/** This transaction type creates an escrow object. */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/Escrow.h>
#endif
TRANSACTION(ttESCROW_CREATE, 1, EscrowCreate, noPriv, ({
    {sfDestination, soeREQUIRED},
    {sfAmount, soeREQUIRED},
    {sfCondition, soeOPTIONAL},
    {sfCancelAfter, soeOPTIONAL},
    {sfFinishAfter, soeOPTIONAL},
    {sfDestinationTag, soeOPTIONAL},
}))

/** This transaction type completes an existing escrow. */
TRANSACTION(ttESCROW_FINISH, 2, EscrowFinish, noPriv, ({
    {sfOwner, soeREQUIRED},
    {sfOfferSequence, soeREQUIRED},
    {sfFulfillment, soeOPTIONAL},
    {sfCondition, soeOPTIONAL},
    {sfCredentialIDs, soeOPTIONAL},
}))


/** This transaction type adjusts various account settings. */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/SetAccount.h>
#endif
TRANSACTION(ttACCOUNT_SET, 3, AccountSet, noPriv, ({
    {sfEmailHash, soeOPTIONAL},
    {sfWalletLocator, soeOPTIONAL},
    {sfWalletSize, soeOPTIONAL},
    {sfMessageKey, soeOPTIONAL},
    {sfDomain, soeOPTIONAL},
    {sfTransferRate, soeOPTIONAL},
    {sfSetFlag, soeOPTIONAL},
    {sfClearFlag, soeOPTIONAL},
    {sfTickSize, soeOPTIONAL},
    {sfNFTokenMinter, soeOPTIONAL},
}))

/** This transaction type cancels an existing escrow. */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/Escrow.h>
#endif
TRANSACTION(ttESCROW_CANCEL, 4, EscrowCancel, noPriv, ({
    {sfOwner, soeREQUIRED},
    {sfOfferSequence, soeREQUIRED},
}))

/** This transaction type sets or clears an account's "regular key". */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/SetRegularKey.h>
#endif
TRANSACTION(ttREGULAR_KEY_SET, 5, SetRegularKey, noPriv, ({
    {sfRegularKey, soeOPTIONAL},
}))

// 6 deprecated

/** This transaction type creates an offer to trade one asset for another. */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/CreateOffer.h>
#endif
TRANSACTION(ttOFFER_CREATE, 7, OfferCreate, noPriv, ({
    {sfTakerPays, soeREQUIRED},
    {sfTakerGets, soeREQUIRED},
    {sfExpiration, soeOPTIONAL},
    {sfOfferSequence, soeOPTIONAL},
}))

/** This transaction type cancels existing offers to trade one asset for another. */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/CancelOffer.h>
#endif
TRANSACTION(ttOFFER_CANCEL, 8, OfferCancel, noPriv, ({
    {sfOfferSequence, soeREQUIRED},
}))

// 9 deprecated

/** This transaction type creates a new set of tickets. */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/CreateTicket.h>
#endif
TRANSACTION(ttTICKET_CREATE, 10, TicketCreate, noPriv, ({
    {sfTicketCount, soeREQUIRED},
}))

// 11 deprecated

/** This transaction type modifies the signer list associated with an account. */
// The SignerEntries are optional because a SignerList is deleted by
// setting the SignerQuorum to zero and omitting SignerEntries.
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/SetSignerList.h>
#endif
TRANSACTION(ttSIGNER_LIST_SET, 12, SignerListSet, noPriv, ({
    {sfSignerQuorum, soeREQUIRED},
    {sfSignerEntries, soeOPTIONAL},
}))

/** This transaction type creates a new unidirectional XRP payment channel. */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/PayChan.h>
#endif
TRANSACTION(ttPAYCHAN_CREATE, 13, PaymentChannelCreate, noPriv, ({
    {sfDestination, soeREQUIRED},
    {sfAmount, soeREQUIRED},
    {sfSettleDelay, soeREQUIRED},
    {sfPublicKey, soeREQUIRED},
    {sfCancelAfter, soeOPTIONAL},
    {sfDestinationTag, soeOPTIONAL},
}))

/** This transaction type funds an existing unidirectional XRP payment channel. */
TRANSACTION(ttPAYCHAN_FUND, 14, PaymentChannelFund, noPriv, ({
    {sfChannel, soeREQUIRED},
    {sfAmount, soeREQUIRED},
    {sfExpiration, soeOPTIONAL},
}))

/** This transaction type submits a claim against an existing unidirectional payment channel. */
TRANSACTION(ttPAYCHAN_CLAIM, 15, PaymentChannelClaim, noPriv, ({
    {sfChannel, soeREQUIRED},
    {sfAmount, soeOPTIONAL},
    {sfBalance, soeOPTIONAL},
    {sfSignature, soeOPTIONAL},
    {sfPublicKey, soeOPTIONAL},
    {sfCredentialIDs, soeOPTIONAL},
}))

/** This transaction type creates a new check. */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/CreateCheck.h>
#endif
TRANSACTION(ttCHECK_CREATE, 16, CheckCreate, noPriv, ({
    {sfDestination, soeREQUIRED},
    {sfSendMax, soeREQUIRED},
    {sfExpiration, soeOPTIONAL},
    {sfDestinationTag, soeOPTIONAL},
    {sfInvoiceID, soeOPTIONAL},
}))

/** This transaction type cashes an existing check. */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/CashCheck.h>
#endif
TRANSACTION(ttCHECK_CASH, 17, CheckCash, noPriv, ({
    {sfCheckID, soeREQUIRED},
    {sfAmount, soeOPTIONAL},
    {sfDeliverMin, soeOPTIONAL},
}))

/** This transaction type cancels an existing check. */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/CancelCheck.h>
#endif
TRANSACTION(ttCHECK_CANCEL, 18, CheckCancel, noPriv, ({
    {sfCheckID, soeREQUIRED},
}))

/** This transaction type grants or revokes authorization to transfer funds. */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/DepositPreauth.h>
#endif
TRANSACTION(ttDEPOSIT_PREAUTH, 19, DepositPreauth, noPriv, ({
    {sfAuthorize, soeOPTIONAL},
    {sfUnauthorize, soeOPTIONAL},
    {sfAuthorizeCredentials, soeOPTIONAL},
    {sfUnauthorizeCredentials, soeOPTIONAL},
}))

/** This transaction type modifies a trustline between two accounts. */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/SetTrust.h>
#endif
TRANSACTION(ttTRUST_SET, 20, TrustSet, noPriv, ({
    {sfLimitAmount, soeOPTIONAL},
    {sfQualityIn, soeOPTIONAL},
    {sfQualityOut, soeOPTIONAL},
}))

/** This transaction type deletes an existing account. */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/DeleteAccount.h>
#endif
TRANSACTION(ttACCOUNT_DELETE, 21, AccountDelete, mustDeleteAcct, ({
    {sfDestination, soeREQUIRED},
    {sfDestinationTag, soeOPTIONAL},
    {sfCredentialIDs, soeOPTIONAL},
}))

// 22 reserved

/** This transaction mints a new NFT. */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/NFTokenMint.h>
#endif
TRANSACTION(ttNFTOKEN_MINT, 25, NFTokenMint, changeNFTCounts, ({
    {sfNFTokenTaxon, soeREQUIRED},
    {sfTransferFee, soeOPTIONAL},
    {sfIssuer, soeOPTIONAL},
    {sfURI, soeOPTIONAL},
    {sfAmount, soeOPTIONAL},
    {sfDestination, soeOPTIONAL},
    {sfExpiration, soeOPTIONAL},
}))

/** This transaction burns (i.e. destroys) an existing NFT. */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/NFTokenBurn.h>
#endif
TRANSACTION(ttNFTOKEN_BURN, 26, NFTokenBurn, changeNFTCounts, ({
    {sfNFTokenID, soeREQUIRED},
    {sfOwner, soeOPTIONAL},
}))

/** This transaction creates a new offer to buy or sell an NFT. */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/NFTokenCreateOffer.h>
#endif
TRANSACTION(ttNFTOKEN_CREATE_OFFER, 27, NFTokenCreateOffer, noPriv, ({
    {sfNFTokenID, soeREQUIRED},
    {sfAmount, soeREQUIRED},
    {sfDestination, soeOPTIONAL},
    {sfOwner, soeOPTIONAL},
    {sfExpiration, soeOPTIONAL},
}))

/** This transaction cancels an existing offer to buy or sell an existing NFT. */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/NFTokenCancelOffer.h>
#endif
TRANSACTION(ttNFTOKEN_CANCEL_OFFER, 28, NFTokenCancelOffer, noPriv, ({
    {sfNFTokenOffers, soeREQUIRED},
}))

/** This transaction accepts an existing offer to buy or sell an existing  NFT. */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/NFTokenAcceptOffer.h>
#endif
TRANSACTION(ttNFTOKEN_ACCEPT_OFFER, 29, NFTokenAcceptOffer, noPriv, ({
    {sfNFTokenBuyOffer, soeOPTIONAL},
    {sfNFTokenSellOffer, soeOPTIONAL},
    {sfNFTokenBrokerFee, soeOPTIONAL},
}))

/** This transaction claws back issued tokens. */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/Clawback.h>
#endif
TRANSACTION(ttCLAWBACK, 30, Clawback, noPriv, ({
    {sfAmount, soeREQUIRED, soeMPTSupported},
    {sfHolder, soeOPTIONAL},
}))

/** This transaction claws back tokens from an AMM pool. */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/AMMClawback.h>
#endif
TRANSACTION(ttAMM_CLAWBACK, 31, AMMClawback,
    mayDeleteAcct | overrideFreeze, ({
    {sfHolder, soeREQUIRED},
    {sfAsset, soeREQUIRED},
    {sfAsset2, soeREQUIRED},
    {sfAmount, soeOPTIONAL},
}))

/** This transaction type creates an AMM instance */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/AMMCreate.h>
#endif
TRANSACTION(ttAMM_CREATE, 35, AMMCreate, createPseudoAcct, ({
    {sfAmount, soeREQUIRED},
    {sfAmount2, soeREQUIRED},
    {sfTradingFee, soeREQUIRED},
}))

/** This transaction type deposits into an AMM instance */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/AMMDeposit.h>
#endif
TRANSACTION(ttAMM_DEPOSIT, 36, AMMDeposit, noPriv, ({
    {sfAsset, soeREQUIRED},
    {sfAsset2, soeREQUIRED},
    {sfAmount, soeOPTIONAL},
    {sfAmount2, soeOPTIONAL},
    {sfEPrice, soeOPTIONAL},
    {sfLPTokenOut, soeOPTIONAL},
    {sfTradingFee, soeOPTIONAL},
}))

/** This transaction type withdraws from an AMM instance */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/AMMWithdraw.h>
#endif
TRANSACTION(ttAMM_WITHDRAW, 37, AMMWithdraw, mayDeleteAcct, ({
    {sfAsset, soeREQUIRED},
    {sfAsset2, soeREQUIRED},
    {sfAmount, soeOPTIONAL},
    {sfAmount2, soeOPTIONAL},
    {sfEPrice, soeOPTIONAL},
    {sfLPTokenIn, soeOPTIONAL},
}))

/** This transaction type votes for the trading fee */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/AMMVote.h>
#endif
TRANSACTION(ttAMM_VOTE, 38, AMMVote, noPriv, ({
    {sfAsset, soeREQUIRED},
    {sfAsset2, soeREQUIRED},
    {sfTradingFee, soeREQUIRED},
}))

/** This transaction type bids for the auction slot */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/AMMBid.h>
#endif
TRANSACTION(ttAMM_BID, 39, AMMBid, noPriv, ({
    {sfAsset, soeREQUIRED},
    {sfAsset2, soeREQUIRED},
    {sfBidMin, soeOPTIONAL},
    {sfBidMax, soeOPTIONAL},
    {sfAuthAccounts, soeOPTIONAL},
}))

/** This transaction type deletes AMM in the empty state */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/AMMDelete.h>
#endif
TRANSACTION(ttAMM_DELETE, 40, AMMDelete, mustDeleteAcct, ({
    {sfAsset, soeREQUIRED},
    {sfAsset2, soeREQUIRED},
}))

/** This transactions creates a crosschain sequence number */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/XChainBridge.h>
#endif
TRANSACTION(ttXCHAIN_CREATE_CLAIM_ID, 41, XChainCreateClaimID, noPriv, ({
    {sfXChainBridge, soeREQUIRED},
    {sfSignatureReward, soeREQUIRED},
    {sfOtherChainSource, soeREQUIRED},
}))

/** This transactions initiates a crosschain transaction */
TRANSACTION(ttXCHAIN_COMMIT, 42, XChainCommit, noPriv, ({
    {sfXChainBridge, soeREQUIRED},
    {sfXChainClaimID, soeREQUIRED},
    {sfAmount, soeREQUIRED},
    {sfOtherChainDestination, soeOPTIONAL},
}))

/** This transaction completes a crosschain transaction */
TRANSACTION(ttXCHAIN_CLAIM, 43, XChainClaim, noPriv, ({
    {sfXChainBridge, soeREQUIRED},
    {sfXChainClaimID, soeREQUIRED},
    {sfDestination, soeREQUIRED},
    {sfDestinationTag, soeOPTIONAL},
    {sfAmount, soeREQUIRED},
}))

/** This transaction initiates a crosschain account create transaction */
TRANSACTION(ttXCHAIN_ACCOUNT_CREATE_COMMIT, 44, XChainAccountCreateCommit, noPriv, ({
    {sfXChainBridge, soeREQUIRED},
    {sfDestination, soeREQUIRED},
    {sfAmount, soeREQUIRED},
    {sfSignatureReward, soeREQUIRED},
}))

/** This transaction adds an attestation to a claim */
TRANSACTION(ttXCHAIN_ADD_CLAIM_ATTESTATION, 45, XChainAddClaimAttestation, createAcct, ({
    {sfXChainBridge, soeREQUIRED},

    {sfAttestationSignerAccount, soeREQUIRED},
    {sfPublicKey, soeREQUIRED},
    {sfSignature, soeREQUIRED},
    {sfOtherChainSource, soeREQUIRED},
    {sfAmount, soeREQUIRED},
    {sfAttestationRewardAccount, soeREQUIRED},
    {sfWasLockingChainSend, soeREQUIRED},

    {sfXChainClaimID, soeREQUIRED},
    {sfDestination, soeOPTIONAL},
}))

/** This transaction adds an attestation to an account */
TRANSACTION(ttXCHAIN_ADD_ACCOUNT_CREATE_ATTESTATION, 46, XChainAddAccountCreateAttestation, createAcct, ({
    {sfXChainBridge, soeREQUIRED},

    {sfAttestationSignerAccount, soeREQUIRED},
    {sfPublicKey, soeREQUIRED},
    {sfSignature, soeREQUIRED},
    {sfOtherChainSource, soeREQUIRED},
    {sfAmount, soeREQUIRED},
    {sfAttestationRewardAccount, soeREQUIRED},
    {sfWasLockingChainSend, soeREQUIRED},

    {sfXChainAccountCreateCount, soeREQUIRED},
    {sfDestination, soeREQUIRED},
    {sfSignatureReward, soeREQUIRED},
}))

/** This transaction modifies a sidechain */
TRANSACTION(ttXCHAIN_MODIFY_BRIDGE, 47, XChainModifyBridge, noPriv, ({
    {sfXChainBridge, soeREQUIRED},
    {sfSignatureReward, soeOPTIONAL},
    {sfMinAccountCreateAmount, soeOPTIONAL},
}))

/** This transactions creates a sidechain */
TRANSACTION(ttXCHAIN_CREATE_BRIDGE, 48, XChainCreateBridge, noPriv, ({
    {sfXChainBridge, soeREQUIRED},
    {sfSignatureReward, soeREQUIRED},
    {sfMinAccountCreateAmount, soeOPTIONAL},
}))

/** This transaction type creates or updates a DID */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/DID.h>
#endif
TRANSACTION(ttDID_SET, 49, DIDSet, noPriv, ({
    {sfDIDDocument, soeOPTIONAL},
    {sfURI, soeOPTIONAL},
    {sfData, soeOPTIONAL},
}))

/** This transaction type deletes a DID */
TRANSACTION(ttDID_DELETE, 50, DIDDelete, noPriv, ({}))

/** This transaction type creates an Oracle instance */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/SetOracle.h>
#endif
TRANSACTION(ttORACLE_SET, 51, OracleSet, noPriv, ({
    {sfOracleDocumentID, soeREQUIRED},
    {sfProvider, soeOPTIONAL},
    {sfURI, soeOPTIONAL},
    {sfAssetClass, soeOPTIONAL},
    {sfLastUpdateTime, soeREQUIRED},
    {sfPriceDataSeries, soeREQUIRED},
}))

/** This transaction type deletes an Oracle instance */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/DeleteOracle.h>
#endif
TRANSACTION(ttORACLE_DELETE, 52, OracleDelete, noPriv, ({
    {sfOracleDocumentID, soeREQUIRED},
}))

/** This transaction type fixes a problem in the ledger state */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/LedgerStateFix.h>
#endif
TRANSACTION(ttLEDGER_STATE_FIX, 53, LedgerStateFix, noPriv, ({
    {sfLedgerFixType, soeREQUIRED},
    {sfOwner, soeOPTIONAL},
}))

/** This transaction type creates a MPTokensIssuance instance */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/MPTokenIssuanceCreate.h>
#endif
TRANSACTION(ttMPTOKEN_ISSUANCE_CREATE, 54, MPTokenIssuanceCreate,
    createMPTIssuance, ({
    {sfAssetScale, soeOPTIONAL},
    {sfTransferFee, soeOPTIONAL},
    {sfMaximumAmount, soeOPTIONAL},
    {sfMPTokenMetadata, soeOPTIONAL},
}))

/** This transaction type destroys a MPTokensIssuance instance */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/MPTokenIssuanceDestroy.h>
#endif
TRANSACTION(ttMPTOKEN_ISSUANCE_DESTROY, 55, MPTokenIssuanceDestroy,
    destroyMPTIssuance, ({
    {sfMPTokenIssuanceID, soeREQUIRED},
}))

/** This transaction type sets flags on a MPTokensIssuance or MPToken instance */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/MPTokenIssuanceSet.h>
#endif
TRANSACTION(ttMPTOKEN_ISSUANCE_SET, 56, MPTokenIssuanceSet, noPriv, ({
    {sfMPTokenIssuanceID, soeREQUIRED},
    {sfHolder, soeOPTIONAL},
}))

/** This transaction type authorizes a MPToken instance */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/MPTokenAuthorize.h>
#endif
TRANSACTION(ttMPTOKEN_AUTHORIZE, 57, MPTokenAuthorize, mustAuthorizeMPT, ({
    {sfMPTokenIssuanceID, soeREQUIRED},
    {sfHolder, soeOPTIONAL},
}))

/** This transaction type create an Credential instance */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/Credentials.h>
#endif
TRANSACTION(ttCREDENTIAL_CREATE, 58, CredentialCreate, noPriv, ({
    {sfSubject, soeREQUIRED},
    {sfCredentialType, soeREQUIRED},
    {sfExpiration, soeOPTIONAL},
    {sfURI, soeOPTIONAL},
}))

/** This transaction type accept an Credential object */
TRANSACTION(ttCREDENTIAL_ACCEPT, 59, CredentialAccept, noPriv, ({
    {sfIssuer, soeREQUIRED},
    {sfCredentialType, soeREQUIRED},
}))

/** This transaction type delete an Credential object */
TRANSACTION(ttCREDENTIAL_DELETE, 60, CredentialDelete, noPriv, ({
    {sfSubject, soeOPTIONAL},
    {sfIssuer, soeOPTIONAL},
    {sfCredentialType, soeREQUIRED},
}))

/** This transaction type modify a NFToken */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/NFTokenModify.h>
#endif
TRANSACTION(ttNFTOKEN_MODIFY, 61, NFTokenModify, noPriv, ({
    {sfNFTokenID, soeREQUIRED},
    {sfOwner, soeOPTIONAL},
    {sfURI, soeOPTIONAL},
}))

/** This transaction type creates or modifies a Permissioned Domain */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/PermissionedDomainSet.h>
#endif
TRANSACTION(ttPERMISSIONED_DOMAIN_SET, 62, PermissionedDomainSet, noPriv, ({
    {sfDomainID, soeOPTIONAL},
    {sfAcceptedCredentials, soeREQUIRED},
}))

/** This transaction type deletes a Permissioned Domain */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/PermissionedDomainDelete.h>
#endif
TRANSACTION(ttPERMISSIONED_DOMAIN_DELETE, 63, PermissionedDomainDelete, noPriv, ({
    {sfDomainID, soeREQUIRED},
}))

/** This transaction creates a single asset vault. */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/VaultCreate.h>
#endif
TRANSACTION(ttVAULT_CREATE, 64, VaultCreate,
    createPseudoAcct | createMPTIssuance, ({
    {sfAsset, soeREQUIRED, soeMPTSupported},
    {sfAssetsMaximum, soeOPTIONAL},
    {sfMPTokenMetadata, soeOPTIONAL},
    {sfDomainID, soeOPTIONAL}, // PermissionedDomainID
    {sfWithdrawalPolicy, soeOPTIONAL},
    {sfData, soeOPTIONAL},
}))

/** This transaction updates a single asset vault. */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/VaultSet.h>
#endif
TRANSACTION(ttVAULT_SET, 65, VaultSet, noPriv, ({
    {sfVaultID, soeREQUIRED},
    {sfAssetsMaximum, soeOPTIONAL},
    {sfDomainID, soeOPTIONAL}, // PermissionedDomainID
    {sfData, soeOPTIONAL},
}))

/** This transaction deletes a single asset vault. */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/VaultDelete.h>
#endif
TRANSACTION(ttVAULT_DELETE, 66, VaultDelete,
    mustDeleteAcct | destroyMPTIssuance, ({
    {sfVaultID, soeREQUIRED},
}))

/** This transaction trades assets for shares with a vault. */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/VaultDeposit.h>
#endif
TRANSACTION(ttVAULT_DEPOSIT, 67, VaultDeposit, mayAuthorizeMPT, ({
    {sfVaultID, soeREQUIRED},
    {sfAmount, soeREQUIRED, soeMPTSupported},
}))

/** This transaction trades shares for assets with a vault. */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/VaultWithdraw.h>
#endif
TRANSACTION(ttVAULT_WITHDRAW, 68, VaultWithdraw, noPriv, ({
    {sfVaultID, soeREQUIRED},
    {sfAmount, soeREQUIRED, soeMPTSupported},
    {sfDestination, soeOPTIONAL},
}))

/** This transaction claws back tokens from a vault. */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/VaultClawback.h>
#endif
TRANSACTION(ttVAULT_CLAWBACK, 69, VaultClawback, noPriv, ({
    {sfVaultID, soeREQUIRED},
    {sfHolder, soeREQUIRED},
    {sfAmount, soeOPTIONAL, soeMPTSupported},
}))

/** Reserve 70-73 for future Vault-related transactions */

/** This transaction creates and updates a Loan Broker */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/LoanBrokerSet.h>
#endif
TRANSACTION(ttLOAN_BROKER_SET, 74, LoanBrokerSet,
    createPseudoAcct | mayAuthorizeMPT, ({
    {sfVaultID, soeREQUIRED},
    {sfLoanBrokerID, soeOPTIONAL},
    {sfData, soeOPTIONAL},
    {sfManagementFeeRate, soeOPTIONAL},
    {sfDebtMaximum, soeOPTIONAL},
    {sfCoverRateMinimum, soeOPTIONAL},
    {sfCoverRateLiquidation, soeOPTIONAL},
}))

/** This transaction deletes a Loan Broker */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/LoanBrokerDelete.h>
#endif
TRANSACTION(ttLOAN_BROKER_DELETE, 75, LoanBrokerDelete,
    mustDeleteAcct | mayAuthorizeMPT, ({
    {sfLoanBrokerID, soeREQUIRED},
}))

/** This transaction deposits First Loss Capital into a Loan Broker */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/LoanBrokerCoverDeposit.h>
#endif
TRANSACTION(ttLOAN_BROKER_COVER_DEPOSIT, 76, LoanBrokerCoverDeposit, noPriv, ({
    {sfLoanBrokerID, soeREQUIRED},
    {sfAmount, soeREQUIRED, soeMPTSupported},
}))

/** This transaction withdraws First Loss Capital from a Loan Broker */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/LoanBrokerCoverWithdraw.h>
#endif
TRANSACTION(ttLOAN_BROKER_COVER_WITHDRAW, 77, LoanBrokerCoverWithdraw, noPriv, ({
    {sfLoanBrokerID, soeREQUIRED},
    {sfAmount, soeREQUIRED, soeMPTSupported},
}))

/** This transaction creates a Loan */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/LoanSet.h>
#endif
TRANSACTION(ttLOAN_SET, 78, LoanSet, noPriv, ({
    {sfLoanBrokerID, soeREQUIRED},
    {sfData, soeOPTIONAL},
    {sfCounterparty, soeOPTIONAL},
    {sfCounterpartySignature, soeREQUIRED},
    {sfLoanOriginationFee, soeOPTIONAL},
    {sfLoanServiceFee, soeOPTIONAL},
    {sfLatePaymentFee, soeOPTIONAL},
    {sfClosePaymentFee, soeOPTIONAL},
    {sfOverpaymentFee, soeOPTIONAL},
    {sfInterestRate, soeOPTIONAL},
    {sfLateInterestRate, soeOPTIONAL},
    {sfCloseInterestRate, soeOPTIONAL},
    {sfOverpaymentInterestRate, soeOPTIONAL},
    {sfPrincipalRequested, soeREQUIRED},
    {sfStartDate, soeREQUIRED},
    {sfPaymentTotal, soeOPTIONAL},
    {sfPaymentInterval, soeOPTIONAL},
    {sfGracePeriod, soeOPTIONAL},
}))

/** This transaction deletes an existing Loan */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/LoanDelete.h>
#endif
TRANSACTION(ttLOAN_DELETE, 79, LoanDelete, noPriv, ({
    {sfLoanID, soeREQUIRED},
}))

/** This transaction is used to change the delinquency status of an existing Loan */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/LoanManage.h>
#endif
TRANSACTION(ttLOAN_MANAGE, 80, LoanManage, noPriv, ({
    {sfLoanID, soeREQUIRED},
}))

/** The Borrower uses this transaction to draws funds from the Loan. */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/LoanDraw.h>
#endif
TRANSACTION(ttLOAN_DRAW, 81, LoanDraw, noPriv, ({
    {sfLoanID, soeREQUIRED},
    {sfAmount, soeREQUIRED, soeMPTSupported},
}))

#if 0
/** The Borrower uses this transaction to make a Payment on the Loan. */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/LoanPay.h>
#endif
TRANSACTION(ttLOAN_PAY, 82, LoanPay, noPriv, ({
    {sfLoanID, soeREQUIRED},
    {sfAmount, soeREQUIRED, soeMPTSupported},
}))
#endif

/** This system-generated transaction type is used to update the status of the various amendments.

    For details, see: https://xrpl.org/amendments.html
 */
#if TRANSACTION_INCLUDE
#   include <xrpld/app/tx/detail/Change.h>
#endif
TRANSACTION(ttAMENDMENT, 100, EnableAmendment, noPriv, ({
    {sfLedgerSequence, soeREQUIRED},
    {sfAmendment, soeREQUIRED},
}))

/** This system-generated transaction type is used to update the network's fee settings.
    For details, see: https://xrpl.org/fee-voting.html
 */
TRANSACTION(ttFEE, 101, SetFee, noPriv, ({
    {sfLedgerSequence, soeOPTIONAL},
    // Old version uses raw numbers
    {sfBaseFee, soeOPTIONAL},
    {sfReferenceFeeUnits, soeOPTIONAL},
    {sfReserveBase, soeOPTIONAL},
    {sfReserveIncrement, soeOPTIONAL},
    // New version uses Amounts
    {sfBaseFeeDrops, soeOPTIONAL},
    {sfReserveBaseDrops, soeOPTIONAL},
    {sfReserveIncrementDrops, soeOPTIONAL},
}))

/** This system-generated transaction type is used to update the network's negative UNL

    For details, see: https://xrpl.org/negative-unl.html
 */
TRANSACTION(ttUNL_MODIFY, 102, UNLModify, noPriv, ({
    {sfUNLModifyDisabling, soeREQUIRED},
    {sfLedgerSequence, soeREQUIRED},
    {sfUNLModifyValidator, soeREQUIRED},
}))

