<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rippled: Database Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">rippled
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Database Documentation </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li>NodeStore</li>
<li>Benchmarks</li>
</ul>
<h1><a class="anchor" id="autotoc_md572"></a>
NodeStore</h1>
<h2><a class="anchor" id="autotoc_md573"></a>
Introduction</h2>
<p >A <code>NodeObject</code> is a simple object that the Ledger uses to store entries. It is comprised of a type, a hash and a blob. It can be uniquely identified by the hash, which is a 256 bit hash of the blob. The blob is a variable length block of serialized data. The type identifies what the blob contains. The fields are as follows:</p>
<ul>
<li><p class="startli"><code>mType</code></p>
<p class="startli">An enumeration that determines what the blob holds. There are four different types of objects stored.</p><ul>
<li><p class="startli"><b>ledger</b></p>
<p class="startli">A ledger header.</p>
</li>
<li><p class="startli"><b>transaction</b></p>
<p class="startli">A signed transaction.</p>
</li>
<li><p class="startli"><b>account node</b></p>
<p class="startli">A node in a ledger's account state tree.</p>
</li>
<li><p class="startli"><b>transaction node</b></p>
<p class="startli">A node in a ledger's transaction tree.</p>
</li>
</ul>
</li>
<li><p class="startli"><code>mHash</code></p>
<p class="startli">A 256-bit hash of the blob.</p>
</li>
<li><p class="startli"><code>mData</code></p>
<p class="startli">A blob containing the payload. Stored in the following format.</p>
</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Byte   </th><th class="markdownTableHeadLeft"></th><th class="markdownTableHeadLeft"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">0...7   </td><td class="markdownTableBodyLeft">unused   </td><td class="markdownTableBodyLeft"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">8   </td><td class="markdownTableBodyLeft">type   </td><td class="markdownTableBodyLeft">NodeObjectType enumeration    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">9...end   </td><td class="markdownTableBodyLeft">data   </td><td class="markdownTableBodyLeft">body of the object data   </td></tr>
</table>
<hr  />
<p> The <code>NodeStore</code> provides an interface that stores, in a persistent database, a collection of NodeObjects that rippled uses as its primary representation of ledger entries. All ledger entries are stored as NodeObjects and as such, need to be persisted between launches. If a NodeObject is accessed and is not in memory, it will be retrieved from the database.</p>
<h2><a class="anchor" id="autotoc_md574"></a>
Backend</h2>
<p >The <code>NodeStore</code> implementation provides the <code>Backend</code> abstract interface, which lets different key/value databases to be chosen at run-time. This allows experimentation with different engines. Improvements in the performance of the NodeStore are a constant area of research. The database can be specified in the configuration file [node_db] section as follows.</p>
<p >One or more lines of key / value pairs</p>
<p >Example: </p><div class="fragment"><div class="line">type=RocksDB</div>
<div class="line">path=rocksdb</div>
<div class="line">compression=1</div>
</div><!-- fragment --><p> Choices for 'type' (not case-sensitive)</p>
<ul>
<li><p class="startli"><b>HyperLevelDB</b></p>
<p class="startli">An improved version of LevelDB (preferred).</p>
</li>
<li><p class="startli"><b>LevelDB</b></p>
<p class="startli">Google's LevelDB database (deprecated).</p>
</li>
<li><p class="startli"><b>none</b></p>
<p class="startli">Use no backend.</p>
</li>
<li><p class="startli"><b>RocksDB</b></p>
<p class="startli">Facebook's RocksDB database, builds on LevelDB.</p>
</li>
<li><p class="startli"><b>SQLite</b></p>
<p class="startli">Use SQLite.</p>
</li>
</ul>
<p >'path' speficies where the backend will store its data files.</p>
<p >Choices for 'compression'</p>
<ul>
<li><b>0</b> off</li>
<li><b>1</b> on (default)</li>
</ul>
<h1><a class="anchor" id="autotoc_md575"></a>
Benchmarks</h1>
<p >The <code>NodeStore.Timing</code> test is used to execute a set of read/write workloads to compare current available nodestore backends. It can be executed with:</p>
<div class="fragment"><div class="line">$rippled --unittest=NodeStoreTiming</div>
</div><!-- fragment --><p >It is also possible to use alternate DB config params by passing config strings as <code>--unittest-arg</code>.</p>
<h2><a class="anchor" id="autotoc_md576"></a>
Addendum</h2>
<p >The discussion below refers to a <code>RocksDBQuick</code> backend that has since been removed from the code as it was not working and not maintained. That backend primarily used one of the several rocks <code>Optimize*</code> methods to setup the majority of the DB options/params, whereas the primary RocksDB backend exposes many of the available config options directly. The code for RocksDBQuick can be found in versions of this repo 1.2 and earlier if you need to refer back to it. The conclusions below date from about 2014 and may need revisiting based on newer versions of RocksDB (TBD).</p>
<h2><a class="anchor" id="autotoc_md577"></a>
Discussion</h2>
<p >RocksDBQuickFactory is intended to provide a testbed for comparing potential rocksdb performance with the existing recommended configuration in rippled.cfg. Through various executions and profiling some conclusions are presented below.</p>
<ul>
<li>If the write ahead log is enabled, insert speed soon clogs up under load. The BatchWriter class intends to stop this from blocking the main threads by queuing up writes and running them in a separate thread. However, rocksdb already has separate threads dedicated to flushing the memtable to disk and the memtable is itself an in-memory queue. The result is two queues with a guarantee of durability in between. However if the memtable was used as the sole queue and the rocksdb::Flush() call was manually triggered at opportune moments, possibly just after ledger close, then that would provide similar, but more predictable guarantees. It would also remove an unneeded thread and unnecessary memory usage. An alternative point of view is that because there will always be many other rippled instances running there is no need for such guarantees. The nodes will always be available from another peer.</li>
<li>Lookup in a block was previously using binary search. With rippled's use case it is highly unlikely that two adjacent key/values will ever be requested one after the other. Therefore hash indexing of blocks makes much more sense. Rocksdb has a number of options for hash indexing both memtables and blocks and these need more testing to find the best choice.</li>
<li>The current Database implementation has two forms of caching, so the LRU cache of blocks at Factory level does not make any sense. However, if the hash indexing and potentially the new <a href="http://rocksdb.org/blog/1427/new-bloom-filter-format/">bloom filter</a> can provide faster lookup for non-existent keys, then potentially the caching could exist at Factory level.</li>
<li>Multiple runs of the benchmarks can yield surprisingly different results. This can perhaps be attributed to the asynchronous nature of rocksdb's compaction process. The benchmarks are artifical and create highly unlikely write load to create the dataset to measure different read access patterns. Therefore multiple runs of the benchmarks are required to get a feel for the effectiveness of the changes. This contrasts sharply with the keyvadb benchmarking were highly repeatable timings were discovered. Also realistically sized datasets are required to get a correct insight. The number of 2,000,000 key/values (actually 4,000,000 after the two insert benchmarks complete) is too low to get a full picture.</li>
<li>An interesting side effect of running the benchmarks in a profiler was that a clear pattern of what RocksDB does under the hood was observable. This led to the decision to trial hash indexing and also the discovery of the native CRC32 instruction not being used.</li>
<li>Important point to note that is if this factory is tested with an existing set of sst files none of the old sst files will benefit from indexing changes until they are compacted at a future point in time. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
