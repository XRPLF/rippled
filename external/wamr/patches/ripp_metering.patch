diff --git a/CMakeLists.txt b/CMakeLists.txt
index 88a1642b..aeb29912 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,7 +1,7 @@
 # Copyright (C) 2019 Intel Corporation.  All rights reserved.
 # SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 
-cmake_minimum_required (VERSION 3.14)
+cmake_minimum_required (VERSION 3.20)
 
 option(BUILD_SHARED_LIBS "Build using shared libraries" OFF)
 
diff --git a/core/iwasm/common/wasm_c_api.c b/core/iwasm/common/wasm_c_api.c
index 269ec577..d3758c0d 100644
--- a/core/iwasm/common/wasm_c_api.c
+++ b/core/iwasm/common/wasm_c_api.c
@@ -5389,3 +5389,8 @@ wasm_instance_get_wasm_func_exec_time(const wasm_instance_t *instance,
     return -1.0;
 #endif
 }
+
+wasm_exec_env_t wasm_instance_exec_env(const wasm_instance_t *instance)
+{
+    return wasm_runtime_get_exec_env_singleton(instance->inst_comm_rt);
+}
diff --git a/core/iwasm/common/wasm_exec_env.c b/core/iwasm/common/wasm_exec_env.c
index 47752950..d5821c4f 100644
--- a/core/iwasm/common/wasm_exec_env.c
+++ b/core/iwasm/common/wasm_exec_env.c
@@ -86,7 +86,9 @@ wasm_exec_env_create_internal(struct WASMModuleInstanceCommon *module_inst,
 #endif
 
 #if WASM_ENABLE_INSTRUCTION_METERING != 0
-    exec_env->instructions_to_execute = -1;
+    exec_env->instructions_to_execute = INT64_MAX;
+    for(int i = 0; i < 256; ++i)
+        exec_env->instructions_schedule[i] = 1;
 #endif
 
     return exec_env;
diff --git a/core/iwasm/common/wasm_exec_env.h b/core/iwasm/common/wasm_exec_env.h
index 5d80312f..2713a092 100644
--- a/core/iwasm/common/wasm_exec_env.h
+++ b/core/iwasm/common/wasm_exec_env.h
@@ -89,7 +89,8 @@ typedef struct WASMExecEnv {
 
 #if WASM_ENABLE_INSTRUCTION_METERING != 0
     /* instructions to execute */
-    int instructions_to_execute;
+    int64 instructions_to_execute;
+    int64 instructions_schedule[256];
 #endif
 
 #if WASM_ENABLE_FAST_JIT != 0
diff --git a/core/iwasm/common/wasm_runtime_common.c b/core/iwasm/common/wasm_runtime_common.c
index dcee0aea..2559be21 100644
--- a/core/iwasm/common/wasm_runtime_common.c
+++ b/core/iwasm/common/wasm_runtime_common.c
@@ -2288,10 +2288,26 @@ wasm_runtime_access_exce_check_guard_page()
 #if WASM_ENABLE_INSTRUCTION_METERING != 0
 void
 wasm_runtime_set_instruction_count_limit(WASMExecEnv *exec_env,
-                                         int instructions_to_execute)
+                                         int64 instructions_to_execute)
 {
+    if(instructions_to_execute == -1)
+        instructions_to_execute = INT64_MAX;
     exec_env->instructions_to_execute = instructions_to_execute;
 }
+
+int64
+wasm_runtime_get_instruction_count_limit(WASMExecEnv *exec_env)
+{
+    return exec_env->instructions_to_execute;
+}
+
+void
+wasm_runtime_set_instruction_schedule(WASMExecEnv *exec_env,
+                                         int64 const *instructions_schedule)
+{
+    for(int i = 0; i < 256; ++i)
+        exec_env->instructions_schedule[i] = instructions_schedule[i];
+}
 #endif
 
 WASMFuncType *
@@ -7805,13 +7821,14 @@ wasm_runtime_get_module_name(wasm_module_t module)
 bool
 wasm_runtime_detect_native_stack_overflow(WASMExecEnv *exec_env)
 {
+#if WASM_DISABLE_STACK_HW_BOUND_CHECK == 0
     uint8 *boundary = exec_env->native_stack_boundary;
     RECORD_STACK_USAGE(exec_env, (uint8 *)&boundary);
     if (boundary == NULL) {
         /* the platform doesn't support os_thread_get_stack_boundary */
         return true;
     }
-#if defined(OS_ENABLE_HW_BOUND_CHECK) && WASM_DISABLE_STACK_HW_BOUND_CHECK == 0
+#if defined(OS_ENABLE_HW_BOUND_CHECK)
     uint32 page_size = os_getpagesize();
     uint32 guard_page_count = STACK_OVERFLOW_CHECK_GUARD_PAGE_COUNT;
     boundary = boundary + page_size * guard_page_count;
@@ -7821,6 +7838,7 @@ wasm_runtime_detect_native_stack_overflow(WASMExecEnv *exec_env)
                                    "native stack overflow");
         return false;
     }
+#endif
     return true;
 }
 
@@ -7843,7 +7861,7 @@ wasm_runtime_detect_native_stack_overflow_size(WASMExecEnv *exec_env,
     boundary = boundary - WASM_STACK_GUARD_SIZE + requested_size;
     if ((uint8 *)&boundary < boundary) {
         wasm_runtime_set_exception(wasm_runtime_get_module_inst(exec_env),
-                                   "native stack overflow");
+                                   "native s stack overflow");
         return false;
     }
     return true;
diff --git a/core/iwasm/common/wasm_runtime_common.h b/core/iwasm/common/wasm_runtime_common.h
index 64a6cd79..f4c55e2f 100644
--- a/core/iwasm/common/wasm_runtime_common.h
+++ b/core/iwasm/common/wasm_runtime_common.h
@@ -795,7 +795,14 @@ wasm_runtime_set_native_stack_boundary(WASMExecEnv *exec_env,
 /* See wasm_export.h for description */
 WASM_RUNTIME_API_EXTERN void
 wasm_runtime_set_instruction_count_limit(WASMExecEnv *exec_env,
-                                         int instructions_to_execute);
+                                         int64 instructions_to_execute);
+WASM_RUNTIME_API_EXTERN int64
+wasm_runtime_get_instruction_count_limit(WASMExecEnv *exec_env);
+
+WASM_RUNTIME_API_EXTERN void
+wasm_runtime_set_instruction_schedule(WASMExecEnv *exec_env,
+                                      int64 const *instructions_schedule);
+
 #endif
 
 #if WASM_CONFIGURABLE_BOUNDS_CHECKS != 0
diff --git a/core/iwasm/include/wasm_c_api.h b/core/iwasm/include/wasm_c_api.h
index 241a0eec..9eb0dde1 100644
--- a/core/iwasm/include/wasm_c_api.h
+++ b/core/iwasm/include/wasm_c_api.h
@@ -19,8 +19,10 @@
 #if defined(_MSC_BUILD)
 #if defined(COMPILING_WASM_RUNTIME_API)
 #define WASM_API_EXTERN __declspec(dllexport)
-#else
+#elif defined(_DLL)
 #define WASM_API_EXTERN __declspec(dllimport)
+#else
+#define WASM_API_EXTERN
 #endif
 #else
 #define WASM_API_EXTERN
@@ -701,6 +703,11 @@ WASM_API_EXTERN double wasm_instance_sum_wasm_exec_time(const wasm_instance_t*);
 // func_name. If the function is not found, return 0.
 WASM_API_EXTERN double wasm_instance_get_wasm_func_exec_time(const wasm_instance_t*, const char *);
 
+struct WASMExecEnv;
+typedef struct WASMExecEnv *wasm_exec_env_t;
+
+WASM_API_EXTERN wasm_exec_env_t wasm_instance_exec_env(const wasm_instance_t*);
+
 ///////////////////////////////////////////////////////////////////////////////
 // Convenience
 
diff --git a/core/iwasm/include/wasm_export.h b/core/iwasm/include/wasm_export.h
index b4ab34be..3fd0949f 100644
--- a/core/iwasm/include/wasm_export.h
+++ b/core/iwasm/include/wasm_export.h
@@ -20,8 +20,10 @@
 #if defined(_MSC_BUILD)
 #if defined(COMPILING_WASM_RUNTIME_API)
 #define WASM_RUNTIME_API_EXTERN __declspec(dllexport)
-#else
+#elif defined(_DLL)
 #define WASM_RUNTIME_API_EXTERN __declspec(dllimport)
+#else
+#define WASM_RUNTIME_API_EXTERN
 #endif
 #elif defined(__GNUC__) || defined(__clang__)
 #define WASM_RUNTIME_API_EXTERN __attribute__((visibility("default")))
@@ -1833,7 +1835,14 @@ wasm_runtime_set_native_stack_boundary(wasm_exec_env_t exec_env,
  */
 WASM_RUNTIME_API_EXTERN void
 wasm_runtime_set_instruction_count_limit(wasm_exec_env_t exec_env,
-                                         int instruction_count);
+                                         int64_t instruction_count);
+
+WASM_RUNTIME_API_EXTERN int64_t
+wasm_runtime_get_instruction_count_limit(wasm_exec_env_t exec_env);
+
+WASM_RUNTIME_API_EXTERN void
+wasm_runtime_set_instruction_schedule(wasm_exec_env_t exec_env,
+                                      int64_t const *instructions_schedule);
 
 /**
  * Dump runtime memory consumption, including:
diff --git a/core/iwasm/interpreter/wasm_interp_classic.c b/core/iwasm/interpreter/wasm_interp_classic.c
index 1e98b0fa..ae24ff8b 100644
--- a/core/iwasm/interpreter/wasm_interp_classic.c
+++ b/core/iwasm/interpreter/wasm_interp_classic.c
@@ -1569,13 +1569,14 @@ get_global_addr(uint8 *global_data, WASMGlobalInstance *global)
 }
 
 #if WASM_ENABLE_INSTRUCTION_METERING != 0
-#define CHECK_INSTRUCTION_LIMIT()                                 \
-    if (instructions_left == 0) {                                 \
-        wasm_set_exception(module, "instruction limit exceeded"); \
-        goto got_exception;                                       \
-    }                                                             \
-    else if (instructions_left > 0)                               \
-        instructions_left--;
+#define CHECK_INSTRUCTION_LIMIT()                                     \
+    do {                                                              \
+        instructions_left -= instructions_schedule[opcode];           \
+        if (instructions_left < 0) {                                  \
+            wasm_set_exception(module, "instruction limit exceeded"); \
+            goto got_exception;                                       \
+        }                                                             \
+    } while (0)
 #else
 #define CHECK_INSTRUCTION_LIMIT() (void)0
 #endif
@@ -1625,9 +1626,11 @@ wasm_interp_call_func_bytecode(WASMModuleInstance *module,
     uint32 cache_index, type_index, param_cell_num, cell_num;
 
 #if WASM_ENABLE_INSTRUCTION_METERING != 0
-    int instructions_left = -1;
+    int64 instructions_left = INT64_MAX;
+    int64 const *instructions_schedule = NULL;
     if (exec_env) {
         instructions_left = exec_env->instructions_to_execute;
+        instructions_schedule = exec_env->instructions_schedule;
     }
 #endif
 
@@ -6885,6 +6888,11 @@ wasm_interp_call_func_bytecode(WASMModuleInstance *module,
         FREE_FRAME(exec_env, frame);
         wasm_exec_env_set_cur_frame(exec_env, prev_frame);
 
+#if WASM_ENABLE_INSTRUCTION_METERING != 0
+        if(exec_env)
+            exec_env->instructions_to_execute = instructions_left;
+#endif
+
         if (!prev_frame->ip) {
             /* Called from native. */
             return;
@@ -6925,6 +6933,12 @@ wasm_interp_call_func_bytecode(WASMModuleInstance *module,
         }
 #endif
         SYNC_ALL_TO_FRAME();
+
+#if WASM_ENABLE_INSTRUCTION_METERING != 0
+        if(exec_env)
+            exec_env->instructions_to_execute = instructions_left;
+#endif
+
         return;
 
 #if WASM_ENABLE_LABELS_AS_VALUES == 0
diff --git a/core/iwasm/interpreter/wasm_interp_fast.c b/core/iwasm/interpreter/wasm_interp_fast.c
index 4e5edf41..ab8fa9cc 100644
--- a/core/iwasm/interpreter/wasm_interp_fast.c
+++ b/core/iwasm/interpreter/wasm_interp_fast.c
@@ -106,14 +106,14 @@ typedef float64 CellType_F64;
     } while (0)
 
 #if WASM_ENABLE_INSTRUCTION_METERING != 0
-#define CHECK_INSTRUCTION_LIMIT()                                 \
-    if (instructions_left == 0) {                                 \
-        wasm_set_exception(module, "instruction limit exceeded"); \
-        goto got_exception;                                       \
-    }                                                             \
-    else if (instructions_left > 0)                               \
-        instructions_left--;
-
+#define CHECK_INSTRUCTION_LIMIT()                                     \
+    do {                                                              \
+        instructions_left -= instructions_schedule[opcode];           \
+        if (instructions_left < 0) {                                  \
+            wasm_set_exception(module, "instruction limit exceeded"); \
+            goto got_exception;                                       \
+        }                                                             \
+    } while (0)
 #else
 #define CHECK_INSTRUCTION_LIMIT() (void)0
 #endif
@@ -1454,7 +1454,6 @@ wasm_interp_dump_op_count()
     do {                                               \
         const void *p_label_addr = *(void **)frame_ip; \
         frame_ip += sizeof(void *);                    \
-        CHECK_INSTRUCTION_LIMIT();                     \
         goto *p_label_addr;                            \
     } while (0)
 #else
@@ -1466,7 +1465,6 @@ wasm_interp_dump_op_count()
         /* int32 relative offset was emitted in 64-bit target */          \
         p_label_addr = label_base + (int32)LOAD_U32_WITH_2U16S(frame_ip); \
         frame_ip += sizeof(int32);                                        \
-        CHECK_INSTRUCTION_LIMIT();                                        \
         goto *p_label_addr;                                               \
     } while (0)
 #else
@@ -1477,17 +1475,18 @@ wasm_interp_dump_op_count()
         /* uint32 label address was emitted in 32-bit target */          \
         p_label_addr = (void *)(uintptr_t)LOAD_U32_WITH_2U16S(frame_ip); \
         frame_ip += sizeof(int32);                                       \
-        CHECK_INSTRUCTION_LIMIT();                                       \
         goto *p_label_addr;                                              \
     } while (0)
 #endif
 #endif /* end of WASM_CPU_SUPPORTS_UNALIGNED_ADDR_ACCESS */
-#define HANDLE_OP_END() FETCH_OPCODE_AND_DISPATCH()
+#define HANDLE_OP_END() CHECK_INSTRUCTION_LIMIT(); FETCH_OPCODE_AND_DISPATCH()
 
 #else /* else of WASM_ENABLE_LABELS_AS_VALUES */
 
 #define HANDLE_OP(opcode) case opcode:
-#define HANDLE_OP_END() continue
+#define HANDLE_OP_END()        \
+    CHECK_INSTRUCTION_LIMIT(); \
+    continue
 
 #endif /* end of WASM_ENABLE_LABELS_AS_VALUES */
 
@@ -1508,6 +1507,8 @@ get_global_addr(uint8 *global_data, WASMGlobalInstance *global)
 #endif
 }
 
+static int64 def_instructions_schedule[256] = {[0 ... 255] = 1};
+
 static void
 wasm_interp_call_func_bytecode(WASMModuleInstance *module,
                                WASMExecEnv *exec_env,
@@ -1556,9 +1557,11 @@ wasm_interp_call_func_bytecode(WASMModuleInstance *module,
     uint8 opcode = 0, local_type, *global_addr;
 
 #if WASM_ENABLE_INSTRUCTION_METERING != 0
-    int instructions_left = -1;
+    int64 instructions_left = INT64_MAX;
+    int64 const *instructions_schedule = def_instructions_schedule;
     if (exec_env) {
         instructions_left = exec_env->instructions_to_execute;
+        instructions_schedule = exec_env->instructions_schedule;
     }
 #endif
 #if !defined(OS_ENABLE_HW_BOUND_CHECK) \
@@ -7806,6 +7809,11 @@ wasm_interp_call_func_bytecode(WASMModuleInstance *module,
         FREE_FRAME(exec_env, frame);
         wasm_exec_env_set_cur_frame(exec_env, (WASMRuntimeFrame *)prev_frame);
 
+#if WASM_ENABLE_INSTRUCTION_METERING != 0
+        if (exec_env)
+            exec_env->instructions_to_execute = instructions_left;
+#endif
+
         if (!prev_frame->ip)
             /* Called from native. */
             return;
@@ -7834,6 +7842,10 @@ wasm_interp_call_func_bytecode(WASMModuleInstance *module,
 
     got_exception:
         SYNC_ALL_TO_FRAME();
+#if WASM_ENABLE_INSTRUCTION_METERING != 0
+        if (exec_env)
+            exec_env->instructions_to_execute = instructions_left;
+#endif
         return;
 
 #if WASM_ENABLE_LABELS_AS_VALUES == 0
diff --git a/core/shared/platform/include/platform_wasi_types.h b/core/shared/platform/include/platform_wasi_types.h
index ac1a95ea..e23b500e 100644
--- a/core/shared/platform/include/platform_wasi_types.h
+++ b/core/shared/platform/include/platform_wasi_types.h
@@ -36,7 +36,11 @@ extern "C" {
 #if WASM_ENABLE_UVWASI != 0 || WASM_ENABLE_LIBC_WASI == 0
 #define assert_wasi_layout(expr, message) /* nothing */
 #else
-#define assert_wasi_layout(expr, message) _Static_assert(expr, message)
+    #ifndef _MSC_VER
+        #define assert_wasi_layout(expr, message) _Static_assert(expr, message)
+    #else
+        #define assert_wasi_layout(expr, message) static_assert(expr, message)
+    #endif
 #endif
 
 assert_wasi_layout(_Alignof(int8_t) == 1, "non-wasi data layout");
