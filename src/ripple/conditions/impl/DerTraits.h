//------------------------------------------------------------------------------
/*
    This file is part of rippled: https://github.com/ripple/rippled
    Copyright (c) 2017 Ripple Labs Inc.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose  with  or without fee is hereby granted, provided that the above
    copyright notice and this permission notice appear in all copies.

    THE  SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH  REGARD  TO  THIS  SOFTWARE  INCLUDING  ALL  IMPLIED  WARRANTIES  OF
    MERCHANTABILITY  AND  FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY  SPECIAL ,  DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER  RESULTING  FROM  LOSS  OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION  OF  CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/
//==============================================================================

#ifndef RIPPLE_CONDITIONS_DERTRAITS_H
#define RIPPLE_CONDITIONS_DERTRAITS_H

#include <boost/container/flat_map.hpp>
#include <boost/container/small_vector.hpp>
#include <boost/optional.hpp>

namespace ripple {
namespace cryptoconditions {
namespace der {

struct Encoder;
struct Decoder;

enum TagType {
    tagBoolean = 1,
    tagInteger = 2,
    tagBitString = 3,
    tagOctetString = 4,
    tagNull = 5,
    tagObjectIdentifier = 6,
    tagReal = 9,
    tagEnumerated = 10,
    tagUtf8String = 12,
    tagSequence = 16,
    tagSet = 17
};

/**  Type of the group.

     @note Sometimes this matches the ASN.1 tag number, but not always. In
     particular, a coder in "auto" mode may use different tags, and some of
     these types (`autoSequence`, `sequenceChild`, `choice`, and `fuzzRoot`)
     will never match the tag type. However, the coders need to know the
     additional information, such as when a parent group is a sequence, or an
     autoSequence.
*/

enum class GroupType {
    boolean = tagBoolean,
    integer = tagInteger,
    bitString = tagBitString,
    octetString = tagOctetString,
    null = tagNull,
    objectIdentifier = tagObjectIdentifier,
    real = tagReal,
    enumerated = tagEnumerated,
    utf8String = tagUtf8String,
    sequence = tagSequence,
    set = tagSet,

    // The following are never tag ids.

    // a sequence that has auto generated tag numbers
    autoSequence = 252,
    // a child in an autogenerated sequence. This is useful as the parent when
    // the child is a "choice"
    sequenceChild = 253,
    choice = 254,
    // used in fuzz testing only
    fuzzRoot = 255
};

/** ASN.1 class ids
 */
enum class ClassId { universal, application, contextSpecific, priv };

/** The coder's tag mode.
 */
enum class TagMode {
    /** direct corresponds to ASN.1's `explicit`. Tags will not be automatically assigned.

        @note `explicit` is a c++ keyword, so an alternate name must be used.
    */
    direct,
    /// Tags will be automatically assigned
    automatic
};

/** cache for values that need to be repeatedly computed, and may be expensive to compute.

    @note the cache assume address of the object will not change. This is _not_
          true of some of the wrapper types (SetOfWrapper and
          SequenceOfWrapper), however it should be true of the collection being
          wrapped. In these cases, the address of the collection should be used
          as the key. It is not necessary to cache all types. Primitive types do
          not need to be cached, as their parents will be cached.
 */
class TraitsCache
{
    /** Collection of content lengths for the value at the given address */
    boost::container::flat_map<void const*, std::size_t> lengthCache_;

    /** Collection of sort orders (for der sets) for the value at the give address */
    boost::container::flat_map<void const*, boost::container::small_vector<size_t, 8>>
        sortOrderCache_;

public:
    /** Get the cached content length for the value at the given address

        @result If the value is stored in the cache, an optional set to the
        stored value, otherwise boost::none
     */
    boost::optional<std::size_t>
    length(void const* addr) const;

    /** Set the cached content length for the value at the given address
     */
    void
    length(void const* addr, size_t l);

    /** Get the cached content sort order for the value at the given address

        @result If the value is stored in the cache, an optional set to the
        stored value, otherwise boost::none

        @note sort order is only used for der sets
     */
    boost::optional<boost::container::small_vector<size_t, 8>>
    sortOrder(void const* addr) const;

    /** Set the cached content sort order for the value at the given address

        @note sort order is only used for der sets
     */
    void
    sortOrder(
        void const* addr,
        boost::container::small_vector<size_t, 8> const& so);
};

/** Interface for serializing and deserializing types into a der coder.

   Types that serialized into a der coder need to specialize a `DerCoderTraits`
   class and provide implementations of each of the member functions described
   in this unspecialized class.

   Specialized classes are provided for common C++ types, such as integers,
   strings, buffers, bitsets, etc.

   Since there are two types of collections in ans.1 - sets and sequences - some
   c++ collections like `std::vector` must be wrapped in the helper functions
   `make_sequence` or `make_set` so the coder knows which ASN.1 collection type
   to use. `std::tuple` is always coded as an ASN.1 sequence, since 100% of the
   cryptocondition use-cases serialized tuples as sequences.

   A typical user type is written as an ASN.1 choice type, where each choice
   type is a ASN.1 sequence. This would be implemented in C++ as a class
   hierarchy. Each concrete leaf class represents a choice. The trait is written
   in terms of a `unique_ptr` to the base class. When decoding, the choice is
   used to create the correct concrete leaf class, and the leaf class would
   serialize itself by using a `std::tuple` of each member of the sequence. For
   example `der_decoder >> std::tuple(member1, member2,...) >> der::eos;`
   Encoding is similar: the correct choice is written to the der stream, then
   the data members are serialized using a `std::tuple`. For example:
   `der_encoder << std::tuple(member1, member2,...) << der::eos;`. Since
   encoding and decoding are almost always exact copies, except decoding uses
   `operator>>` while encoding uses `operator<<`, the der encoders offer
   `operator&` which will decode when using a decoder, and encode with using an
   encoder (boost serialization library uses the same operator). Using this
   operator, both the encoder and decoder may be written as `coder &
   std::tuple(member1, member2,...) & der::eos;`.


   @note This unspecialized class should never be instantiated. If it is, a
         `static_assert` will fire. A specialized `DerCoderTraits` must be provided
         for each class that is to be serialized.
 */
template <class T>
struct DerCoderTraits
{
    static_assert(
        sizeof(T) == -1,
        "DerCoderTraits must be specialized for this type");

    /// ans.1 class id
    constexpr static
    ClassId
    classId();

    /// group type
    constexpr static
    GroupType
    groupType();

    /** ans.1 tag type, if known.

        The tagNum for choice types can only be known from the actual value being
        encoded. In these cases `boost::none` is returned.
    */ 
    static
    boost::optional<std::uint8_t> const&
    tagNum();

    /// ans.1 tag type for this given value.
    template <class TT>
    static
    std::uint8_t
    tagNum(TT);

    /** return true if this type is an ASN.1 primitive. return false if this
        type is an ASN.1 constructed type.
     */
    constexpr static
    bool
    primitive();

    /** return the number of bytes required to encode the value, not including
        the preamble

        @param v the value to find the length of
        @param parentGroupType type of the parent group.
        @param encoderTagMode tag mode of the encoder.
        @param traitsCache cache some values that need to be repeatably computed,
               and may be expensive to compute. Some value types will cache lengths and
               sort orders, other values types will not cache any values.
        @param childNumber if this value is stored in a set or a sequence, the child number of
               this value. This is needed to compute the tag size.

        @note Choice parents groups in automatic tag mode are treated specially.
     */
    template <class TT>
    static
    std::uint64_t
    length(
        TT const& v,
        boost::optional<GroupType> const& parentGroupType,
        TagMode encoderTagMode,
        TraitsCache& traitsCache,
        boost::optional<std::uint64_t> const& childNumber=boost::none);

    /// serialize the value into the encoder
    template <class TT>
    static
    void
    encode(Encoder& s, TT v);

    /// deserialize the value from the decoder
    template <class TT>
    static
    void
    decode(Decoder& decoder, TT& v);

    /** compare two values so they sort appropriately for an ASN.1 set. Returns a
       value less than 0 if lhs<rhs, 0 if lsh==rhs, a value greater than zero if
       lhs>rhs

        @param lhs first value to compare
        @param rhs second value to compare
        @param traitsCache cache some values that need to be repeatedly computed,
               and may be expensive to compute. Some value types will cache lengths and
               sort orders, other values types will not cache any values.

        @note ASN.1 lexagraphically compares how the values would be encoded.
              ASN.1 encodes in big endian order.
     */
    static 
    int
    compare(T const& lhs, T const& rhs, TraitsCache& traitsCache);
};

}  // der
}  // cryptoconditions
}  // ripple

#endif
