<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rippled: Fees</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">rippled
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Fees </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >Rippled's fee mechanism consists of several interrelated processes:</p>
<ol type="1">
<li>Rapid Fee escalation</li>
<li>The Transaction Queue</li>
</ol>
<h1><a class="anchor" id="autotoc_md502"></a>
Fee Escalation</h1>
<p >The guiding principal of fee escalation is that when things are going smoothly, fees stay low, but as soon as high levels of traffic appear on the network, fees will grow quickly to extreme levels. This should dissuade malicious users from abusing the system, while giving legitimate users the ability to pay a higher fee to get high-priority transactions into the open ledger, even during unfavorable conditions.</p>
<p >How fees escalate:</p>
<ol type="1">
<li>There is a base fee level of 256, which is the minimum that a typical transaction is required to pay. For a reference transaction, that corresponds to the network base fee, which is currently 10 drops.</li>
<li>However, there is a limit on the number of transactions that can get into an open ledger for that base fee level. The limit will vary based on the health of the consensus process, but will be at least 5.<ul>
<li>If consensus stays healthy, the limit will be the max of the number of transactions in the validated ledger plus 20% or the current limit until it gets to 50, at which point, the limit will be the largest number of transactions plus 20% in the last 20 validated ledgers which had more than 50 transactions. Any time the limit decreases (i.e. a large ledger is no longer recent), the limit will decrease to the new largest value by 10% each time the ledger has more than 50 transactions.</li>
<li>If consensus does not stay healthy, the limit will clamp down to the smaller of the number of transactions in the validated ledger minus 50% or the previous limit minus 50%.</li>
<li>The intended effect of these mechanisms is to allow as many base fee level transactions to get into the ledger as possible while the network is healthy, but to respond quickly to any condition that makes it unhealthy, including, but not limited to, malicious attacks.</li>
</ul>
</li>
<li>Once there are more transactions in the open ledger than indicated by the limit, the required fee level jumps drastically.<ul>
<li>The formula is <code>( lastLedgerMedianFeeLevel * TransactionsInOpenLedger^2 / limit^2 )</code>, and returns a fee level.</li>
</ul>
</li>
<li>That may still be pretty small, but as more transactions get into the ledger, the fee level increases exponentially.<ul>
<li>For example, if the limit is 6, and the median fee is minimal, and assuming all reference transactions, the 8th transaction only requires a level of about 174,000 or about 6800 drops, but the 20th transaction requires a level of about 1,283,000 or about 50,000 drops.</li>
</ul>
</li>
<li>Finally, as each ledger closes, the median fee level of that ledger is computed and used as <code>lastLedgerMedianFeeLevel</code> (with a minimum value of 128,000) in the fee escalation formula for the next open ledger.<ul>
<li>Continuing the example above, if ledger consensus completes with only those 20 transactions, and all of those transactions paid the minimum required fee at each step, the limit will be adjusted from 6 to 24, and the <code>lastLedgerMedianFeeLevel</code> will be about 322,000, which is 12,600 drops for a reference transaction.</li>
<li>This will only require 10 drops for the first 25 transactions, but the 26th transaction will require a level of about 349,150 or about 13,649 drops.</li>
</ul>
</li>
</ol>
<ul>
<li>This example assumes a cold-start scenario, with a single, possibly malicious, user willing to pay arbitrary amounts to get transactions into the open ledger. It ignores the effects of the Transaction Queue. Any lower fee level transactions submitted by other users at the same time as this user's transactions will go into the transaction queue, and will have the first opportunity to be applied to the <em>next</em> open ledger. The next section describes how that works in more detail.</li>
</ul>
<h1><a class="anchor" id="autotoc_md503"></a>
Transaction Queue</h1>
<p >An integral part of making fee escalation work for users of the network is the transaction queue. The queue allows legitimate transactions to be considered by the network for future ledgers if the escalated open ledger fee gets too high. This allows users to submit low priority transactions with a low fee, and wait for high fees to drop. It also allows legitimate users to continue submitting transactions during high traffic periods, and give those transactions a much better chance to succeed.</p>
<ol type="1">
<li>If an incoming transaction meets both the base fee level and the load fee minimum, but does not have a high enough fee level to immediately go into the open ledger, it is instead put into the queue and broadcast to peers. Each peer will then make an independent decision about whether to put the transaction into its open ledger or the queue. In principle, peers with identical open ledgers will come to identical decisions. Any discrepancies will be resolved as usual during consensus.</li>
<li>When consensus completes, the open ledger limit is adjusted, and the required fee level drops back to the base fee level. Before the ledger is made available to external transactions, transactions are applied from the queue to the ledger from highest fee level to lowest. These transactions count against the open ledger limit, so the required fee level may start rising during this process.</li>
<li>Once the queue is empty, or the required fee level rises too high for the remaining transactions in the queue, the ledger is opened up for normal transaction processing.</li>
<li>A transaction in the queue can stay there indefinitely in principle, but in practice, either<ul>
<li>it will eventually get applied to the ledger,</li>
<li>it will attempt to apply to the ledger and fail,</li>
<li>it will attempt to apply to the ledger and retry 10 times,</li>
<li>its last ledger sequence number will expire,</li>
<li>the user will replace it by submitting another transaction with the same sequence number and at least a 25% higher fee, or</li>
<li>it will get dropped when the queue fills up with more valuable transactions. The size limit is computed dynamically, and can hold transactions for the next 20 ledgers (restricted to a minimum of 2000 transactions). The lower the transaction's fee, the more likely that it will get dropped if the network is busy.</li>
</ul>
</li>
</ol>
<p >If a transaction is submitted for an account with one or more transactions already in the queue, and a sequence number that is sequential with the other transactions in the queue for that account, it will be considered for the queue if it meets these additional criteria:</p><ul>
<li>the account has fewer than 10 transactions already in the queue.</li>
<li>all other queued transactions for that account, in the case where they spend the maximum possible XRP, leave enough XRP balance to pay the fee,</li>
<li>the total fees for the other queued transactions are less than both the network's minimum reserve and the account's XRP balance, and</li>
<li>none of the prior queued transactions affect the ability of subsequent transactions to claim a fee.</li>
</ul>
<p >Currently, there is an additional restriction that the queue cannot work with transactions using the <code>sfPreviousTxnID</code> or <code>sfAccountTxnID</code> fields. <code>sfPreviousTxnID</code> is deprecated and shouldn't be used anyway. Future development will make the queue aware of <code>sfAccountTxnID</code> mechanisms.</p>
<h1><a class="anchor" id="autotoc_md504"></a>
Technical Details</h1>
<h2><a class="anchor" id="autotoc_md505"></a>
Fee Level</h2>
<p >"Fee level" is used to allow the cost of different types of transactions to be compared directly. For a reference transaction, the base fee level is 256. If a transaction is submitted with a higher <code>Fee</code> field, the fee level is scaled appropriately.</p>
<p >Examples, assuming a reference transaction base fee of 10 drops:</p>
<ol type="1">
<li>A single-signed reference transaction with <code>Fee=20</code> will have a fee level of <code>20 drop fee * 256 fee level / 10 drop base fee = 512 fee level</code>.</li>
<li>A multi-signed reference transaction with 3 signatures (base fee = 40 drops) and <code>Fee=60</code> will have a fee level of <code>60 drop fee * 256 fee level / ((1tx + 3sigs) * 10 drop base fee) = 384 fee level</code>.</li>
<li>A hypothetical future non-reference transaction with a base fee of 15 drops multi-signed with 5 signatures and <code>Fee=90</code> will have a fee level of <code>90 drop fee * 256 fee level / ((1tx + 5sigs) * 15 drop base fee) = 256 fee level</code>.</li>
</ol>
<p >This demonstrates that a simpler transaction paying less XRP can be more likely to get into the open ledger, or be sorted earlier in the queue than a more complex transaction paying more XRP.</p>
<h2><a class="anchor" id="autotoc_md506"></a>
Load Fee</h2>
<p >Each rippled server maintains a minimum cost threshold based on its current load. If you submit a transaction with a fee that is lower than the current load-based transaction cost of the rippled server, the server neither applies nor relays the transaction to its peers. A transaction is very unlikely to survive the consensus process unless its transaction fee value meets the requirements of a majority of servers.</p>
<h2><a class="anchor" id="autotoc_md507"></a>
Reference Transaction</h2>
<p >In this document, a "Reference Transaction" is any currently implemented single-signed transaction (eg. Payment, Account Set, Offer Create, etc) that requires a fee.</p>
<p >In the future, there may be other transaction types that require more (or less) work for rippled to process. Those transactions may have a higher (or lower) base fee, requiring a correspondingly higher (or lower) fee to get into the same position as a reference transaction.</p>
<h2><a class="anchor" id="autotoc_md508"></a>
Consensus Health</h2>
<p >For consensus to be considered healthy, the peers on the network should largely remain in sync with one another. It is particularly important for the validators to remain in sync, because that is required for participation in consensus. However, the network tolerates some validators being out of sync. Fundamentally, network health is a function of validators reaching consensus on sets of recently submitted transactions.</p>
<p >Another factor to consider is the duration of the consensus process itself. This generally takes under 5 seconds on the main network under low volume. This is based on historical observations. However factors such as transaction volume can increase consensus duration. This is because rippled performs more work as transaction volume increases. Under sufficient load this tends to increase consensus duration. It's possible that relatively high consensus duration indicates a problem, but it is not appropriate to conclude so without investigation. The upper limit for consensus duration should be roughly 20 seconds. That is far above the normal. If the network takes this long to close ledgers, then it is almost certain that there is a problem with the network. This circumstance often coincides with new ledgers with zero transactions.</p>
<h2><a class="anchor" id="autotoc_md509"></a>
Other Constants</h2>
<ul>
<li><em>Base fee transaction limit per ledger</em>. The minimum value of 5 was chosen to ensure the limit never gets so small that the ledger becomes unusable. The "target" value of 50 was chosen so the limit never gets large enough to invite abuse, but keeps up if the network stays healthy and active. These exact values were chosen experimentally, and can easily change in the future.</li>
<li><em>Expected ledger size growth and reduction percentages</em>. The growth value of 20% was chosen to allow the limit to grow quickly as load increases, but not so quickly as to allow bad actors to run unrestricted. The reduction value of 50% was chosen to cause the limit to drop significantly, but not so drastically that the limit cannot quickly recover if the problem is temporary. These exact values were chosen experimentally, and can easily change in the future.</li>
<li><em>Minimum <code>lastLedgerMedianFeeLevel</code></em>. The value of 500 was chosen to ensure that the first escalated fee was more significant and noticable than what the default would allow. This exact value was chosen experimentally, and can easily change in the future.</li>
<li><em>Transaction queue size limit</em>. The limit is computed based on the base fee transaction limit per ledger, so that the queue can grow automatically as the network's performance improves, allowing more transactions per second, and thus more transactions per ledger to process successfully. The limit of 20 ledgers was used to provide a balance between resource (specifically memory) usage, and giving transactions a realistic chance to be processed. The minimum size of 2000 transactions was chosen to allow a decent functional backlog during network congestion conditions. These exact values were chosen experimentally, and can easily change in the future.</li>
<li><em>Maximum retries</em>. A transaction in the queue can attempt to apply to the open ledger, but get a retry (<code>ter</code>) code up to 10 times, at which point, it will be removed from the queue and dropped. The value was chosen to be large enough to allow temporary failures to clear up, but small enough that the queue doesn't fill up with stale transactions which prevent lower fee level, but more likely to succeed, transactions from queuing.</li>
<li><em>Maximum transactions per account</em>. A single account can have up to 10 transactions in the queue at any given time. This is primarily to mitigate the lost cost of broadcasting multiple transactions if one of the earlier ones fails or is otherwise removed from the queue without being applied to the open ledger. The value was chosen arbitrarily, and can easily change in the future.</li>
<li><em>Minimum last ledger sequence buffer</em>. If a transaction has a <code>LastLedgerSequence</code> value, and cannot be processed into the open ledger, that <code>LastLedgerSequence</code> must be at least 2 more than the sequence number of the open ledger to be considered for the queue. The value was chosen to provide a balance between letting the user control the lifespan of the transaction, and giving a queued transaction a chance to get processed out of the queue before getting discarded, particularly since it may have dependent transactions also in the queue, which will never succeed if this one is discarded.</li>
<li><em>Replaced transaction fee increase</em>. Any transaction in the queue can be replaced by another transaction with the same sequence number and at least a 25% higher fee level. The 25% increase is intended to cover the resource cost incurred by broadcasting the original transaction to the network. This value was chosen experimentally, and can easily change in the future.</li>
</ul>
<h2><a class="anchor" id="autotoc_md510"></a>
&lt;tt&gt;fee&lt;/tt&gt; command</h2>
<p ><b>The <code>fee</code> RPC and WebSocket command is still experimental, and may change without warning.</b></p>
<p ><code>fee</code> takes no parameters, and returns information about the current local fee escalation and transaction queue state as both fee levels and drops. The drop values assume a single-singed reference transaction. It is up to the user to compute the necessary fees for other types of transactions. (E.g. multiply all drop values by 5 for a multi-signed transaction with 4 signatures.)</p>
<p >The <code>fee</code> result is always instantanteous, and relates to the open ledger. It includes the sequence number of the current open ledger, but may not make sense if rippled is not synced to the network.</p>
<p >Result format: </p><div class="fragment"><div class="line">{</div>
<div class="line">   &quot;result&quot; : {</div>
<div class="line">      &quot;current_ledger_size&quot; : &quot;16&quot;, // number of transactions in the open ledger</div>
<div class="line">      &quot;current_queue_size&quot; : &quot;2&quot;, // number of transactions waiting in the queue</div>
<div class="line">      &quot;expected_ledger_size&quot; : &quot;15&quot;, // one less than the number of transactions that can get into the open ledger for the base fee.</div>
<div class="line">      &quot;max_queue_size&quot; : &quot;300&quot;, // number of transactions allowed into the queue</div>
<div class="line">      &quot;ledger_current_index&quot; : 123456789, // sequence number of the current open ledger</div>
<div class="line">      &quot;levels&quot; : {</div>
<div class="line">         &quot;reference_level&quot; : &quot;256&quot;, // level of a reference transaction. Always 256.</div>
<div class="line">         &quot;minimum_level&quot; : &quot;256&quot;, // minimum fee level to get into the queue. If &gt;256, indicates the queue is full.</div>
<div class="line">         &quot;median_level&quot; : &quot;281600&quot;, // lastLedgerMedianFeeLevel used in escalation calculations.</div>
<div class="line">         &quot;open_ledger_level&quot; : &quot;320398&quot; // minimum fee level to get into the open ledger immediately.</div>
<div class="line">      },</div>
<div class="line">      &quot;drops&quot; : {</div>
<div class="line">         &quot;base_fee&quot; : &quot;10&quot;, // base fee of a reference transaction in drops.</div>
<div class="line">         &quot;minimum_fee&quot; : &quot;10&quot;, // minimum drops to get a reference transaction into the queue. If &gt;base_fee, indicates the queue is full.</div>
<div class="line">         &quot;median_fee&quot; : &quot;11000&quot;, // drop equivalent of &quot;median_level&quot; for a reference transaction.</div>
<div class="line">         &quot;open_ledger_fee&quot; : &quot;12516&quot; // minimum drops to get a reference transaction into the open ledger immediately.</div>
<div class="line">      }</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md511"></a>
&lt;a href="https://xrpl.org/server_info.html" &gt;&lt;tt&gt;server_info&lt;/tt&gt;&lt;/a&gt; command</h2>
<p ><b>The fields listed here are still experimental, and may change without warning.</b></p>
<p >Up to two fields in <code>server_info</code> output are related to fee escalation.</p>
<ol type="1">
<li><code>load_factor_fee_escalation</code>: The factor on base transaction cost that a transaction must pay to get into the open ledger. This value can change quickly as transactions are processed from the network and ledgers are closed. If not escalated, the value is 1, so will not be returned.</li>
<li><code>load_factor_fee_queue</code>: If the queue is full, this is the factor on base transaction cost that a transaction must pay to get into the queue. If not full, the value is 1, so will not be returned.</li>
</ol>
<p >In all cases, the transaction fee must be high enough to overcome both <code>load_factor_fee_queue</code> and <code>load_factor</code> to be considered. It does not need to overcome <code>load_factor_fee_escalation</code>, though if it does not, it is more likely to be queued than immediately processed into the open ledger.</p>
<h2><a class="anchor" id="autotoc_md512"></a>
&lt;a href="https://xrpl.org/server_state.html" &gt;&lt;tt&gt;server_state&lt;/tt&gt;&lt;/a&gt; command</h2>
<p ><b>The fields listed here are still experimental, and may change without warning.</b></p>
<p >Three fields in <code>server_state</code> output are related to fee escalation.</p>
<ol type="1">
<li><code>load_factor_fee_escalation</code>: The factor on base transaction cost that a transaction must pay to get into the open ledger. This value can change quickly as transactions are processed from the network and ledgers are closed. The ratio between this value and <code>load_factor_fee_reference</code> determines the multiplier for transaction fees to get into the current open ledger.</li>
<li><code>load_factor_fee_queue</code>: This is the factor on base transaction cost that a transaction must pay to get into the queue. The ratio between this value and <code>load_factor_fee_reference</code> determines the multiplier for transaction fees to get into the transaction queue to be considered for a later ledger.</li>
<li><code>load_factor_fee_reference</code>: Like <code>load_base</code>, this is the baseline that is used to scale fee escalation computations.</li>
</ol>
<p >In all cases, the transaction fee must be high enough to overcome both <code>load_factor_fee_queue</code> and <code>load_factor</code> to be considered. It does not need to overcome <code>load_factor_fee_escalation</code>, though if it does not, it is more likely to be queued than immediately processed into the open ledger. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
