<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rippled: ripple::TaggedPointer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">rippled
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceripple.html">ripple</a></li><li class="navelem"><a class="el" href="classripple_1_1TaggedPointer.html">TaggedPointer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classripple_1_1TaggedPointer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ripple::TaggedPointer Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classripple_1_1TaggedPointer.html" title="TaggedPointer is a combination of a pointer and a mask stored in the lowest two bits.">TaggedPointer</a> is a combination of a pointer and a mask stored in the lowest two bits.  
 <a href="classripple_1_1TaggedPointer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="TaggedPointer_8h_source.html">TaggedPointer.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for ripple::TaggedPointer:</div>
<div class="dyncontent">
<div class="center"><img src="classripple_1_1TaggedPointer__coll__graph.png" border="0" usemap="#aripple_1_1TaggedPointer_coll__map" alt="Collaboration graph"/></div>
<map name="aripple_1_1TaggedPointer_coll__map" id="aripple_1_1TaggedPointer_coll__map">
<area shape="rect" title="TaggedPointer is a combination of a pointer and a mask stored in the lowest two bits." alt="" coords="5,123,164,148"/>
<area shape="rect" target="_parent" href="http://en.cppreference.com/w/cpp/types/integer.html" title=" " alt="" coords="32,5,137,31"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structripple_1_1TaggedPointer_1_1RawAllocateTag.html">RawAllocateTag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afbb502b281e5ca39f59cda1fd638e73c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classripple_1_1TaggedPointer.html#afbb502b281e5ca39f59cda1fd638e73c">TaggedPointer</a> ()=delete</td></tr>
<tr class="separator:afbb502b281e5ca39f59cda1fd638e73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7736e90fee32067aa2d91894003d37c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classripple_1_1TaggedPointer.html#ae7736e90fee32067aa2d91894003d37c">TaggedPointer</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint8_t</a> numChildren)</td></tr>
<tr class="separator:ae7736e90fee32067aa2d91894003d37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51883d57e164a3944e03ae5b23b1af5c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classripple_1_1TaggedPointer.html#a51883d57e164a3944e03ae5b23b1af5c">TaggedPointer</a> (<a class="el" href="classripple_1_1TaggedPointer.html">TaggedPointer</a> &amp;&amp;other, <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint16_t</a> isBranch, <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint8_t</a> toAllocate)</td></tr>
<tr class="memdesc:a51883d57e164a3944e03ae5b23b1af5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor is used change the number of allocated children.  <a href="classripple_1_1TaggedPointer.html#a51883d57e164a3944e03ae5b23b1af5c">More...</a><br /></td></tr>
<tr class="separator:a51883d57e164a3944e03ae5b23b1af5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fb1b04da2e40a9c96f6ed3b25f46aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classripple_1_1TaggedPointer.html#a24fb1b04da2e40a9c96f6ed3b25f46aa">TaggedPointer</a> (<a class="el" href="classripple_1_1TaggedPointer.html">TaggedPointer</a> &amp;&amp;other, <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint16_t</a> srcBranches, <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint16_t</a> dstBranches, <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint8_t</a> toAllocate)</td></tr>
<tr class="memdesc:a24fb1b04da2e40a9c96f6ed3b25f46aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given <code>other</code> with the specified children in <code>srcBranches</code>, create a new <a class="el" href="classripple_1_1TaggedPointer.html" title="TaggedPointer is a combination of a pointer and a mask stored in the lowest two bits.">TaggedPointer</a> with the allocated number of children and the children specified in <code>dstBranches</code>.  <a href="classripple_1_1TaggedPointer.html#a24fb1b04da2e40a9c96f6ed3b25f46aa">More...</a><br /></td></tr>
<tr class="separator:a24fb1b04da2e40a9c96f6ed3b25f46aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45086d014ec681e668f7bc3e16543ae4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classripple_1_1TaggedPointer.html#a45086d014ec681e668f7bc3e16543ae4">TaggedPointer</a> (<a class="el" href="classripple_1_1TaggedPointer.html">TaggedPointer</a> const &amp;)=delete</td></tr>
<tr class="separator:a45086d014ec681e668f7bc3e16543ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2756e93eab705b52cba9b75666f94b05"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classripple_1_1TaggedPointer.html#a2756e93eab705b52cba9b75666f94b05">TaggedPointer</a> (<a class="el" href="classripple_1_1TaggedPointer.html">TaggedPointer</a> &amp;&amp;)</td></tr>
<tr class="separator:a2756e93eab705b52cba9b75666f94b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824caf26851173aaf15cdb7abd9ce8b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classripple_1_1TaggedPointer.html">TaggedPointer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classripple_1_1TaggedPointer.html#a824caf26851173aaf15cdb7abd9ce8b9">operator=</a> (<a class="el" href="classripple_1_1TaggedPointer.html">TaggedPointer</a> &amp;&amp;)</td></tr>
<tr class="separator:a824caf26851173aaf15cdb7abd9ce8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0ddb2f1b39cf44f978ec9ca5683522"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classripple_1_1TaggedPointer.html#ace0ddb2f1b39cf44f978ec9ca5683522">~TaggedPointer</a> ()</td></tr>
<tr class="separator:ace0ddb2f1b39cf44f978ec9ca5683522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad8af935870774f119f6f10f7bb8274"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint8_t</a>, void * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classripple_1_1TaggedPointer.html#a0ad8af935870774f119f6f10f7bb8274">decode</a> () const</td></tr>
<tr class="memdesc:a0ad8af935870774f119f6f10f7bb8274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the tagged pointer into its tag and pointer.  <a href="classripple_1_1TaggedPointer.html#a0ad8af935870774f119f6f10f7bb8274">More...</a><br /></td></tr>
<tr class="separator:a0ad8af935870774f119f6f10f7bb8274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fcb13ead97c21651ae2ea0f60e8909"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classripple_1_1TaggedPointer.html#aa3fcb13ead97c21651ae2ea0f60e8909">capacity</a> () const</td></tr>
<tr class="memdesc:aa3fcb13ead97c21651ae2ea0f60e8909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of elements allocated for each array.  <a href="classripple_1_1TaggedPointer.html#aa3fcb13ead97c21651ae2ea0f60e8909">More...</a><br /></td></tr>
<tr class="separator:aa3fcb13ead97c21651ae2ea0f60e8909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae529fdc057df9e07c40b488d45855b19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classripple_1_1TaggedPointer.html#ae529fdc057df9e07c40b488d45855b19">isDense</a> () const</td></tr>
<tr class="memdesc:ae529fdc057df9e07c40b488d45855b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the arrays have a dense format.  <a href="classripple_1_1TaggedPointer.html#ae529fdc057df9e07c40b488d45855b19">More...</a><br /></td></tr>
<tr class="separator:ae529fdc057df9e07c40b488d45855b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac958a299ad74cb31dc778afdda884a51"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint8_t</a>, <a class="el" href="classripple_1_1SHAMapHash.html">SHAMapHash</a> *, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="classripple_1_1SHAMapTreeNode.html">SHAMapTreeNode</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classripple_1_1TaggedPointer.html#ac958a299ad74cb31dc778afdda884a51">getHashesAndChildren</a> () const</td></tr>
<tr class="memdesc:ac958a299ad74cb31dc778afdda884a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of elements in each array and a pointer to the start of each array.  <a href="classripple_1_1TaggedPointer.html#ac958a299ad74cb31dc778afdda884a51">More...</a><br /></td></tr>
<tr class="separator:ac958a299ad74cb31dc778afdda884a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7fe881693ea0bb3d6539f3591328f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classripple_1_1SHAMapHash.html">SHAMapHash</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classripple_1_1TaggedPointer.html#a7f7fe881693ea0bb3d6539f3591328f4">getHashes</a> () const</td></tr>
<tr class="memdesc:a7f7fe881693ea0bb3d6539f3591328f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <code>hashes</code> array.  <a href="classripple_1_1TaggedPointer.html#a7f7fe881693ea0bb3d6539f3591328f4">More...</a><br /></td></tr>
<tr class="separator:a7f7fe881693ea0bb3d6539f3591328f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b2a492f8e0a4c2e4e35d17cbd95bab"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="classripple_1_1SHAMapTreeNode.html">SHAMapTreeNode</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classripple_1_1TaggedPointer.html#aa0b2a492f8e0a4c2e4e35d17cbd95bab">getChildren</a> () const</td></tr>
<tr class="memdesc:aa0b2a492f8e0a4c2e4e35d17cbd95bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <code>children</code> array.  <a href="classripple_1_1TaggedPointer.html#aa0b2a492f8e0a4c2e4e35d17cbd95bab">More...</a><br /></td></tr>
<tr class="separator:aa0b2a492f8e0a4c2e4e35d17cbd95bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac549f5187a2f29c8fb65a5a399cce913"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:ac549f5187a2f29c8fb65a5a399cce913"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classripple_1_1TaggedPointer.html#ac549f5187a2f29c8fb65a5a399cce913">iterChildren</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint16_t</a> isBranch, F &amp;&amp;f) const</td></tr>
<tr class="memdesc:ac549f5187a2f29c8fb65a5a399cce913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the <code>f</code> callback for all 16 (branchFactor) branches - even if the branch is empty.  <a href="classripple_1_1TaggedPointer.html#ac549f5187a2f29c8fb65a5a399cce913">More...</a><br /></td></tr>
<tr class="separator:ac549f5187a2f29c8fb65a5a399cce913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d143272df241cef3ff904d3291652b"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a00d143272df241cef3ff904d3291652b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classripple_1_1TaggedPointer.html#a00d143272df241cef3ff904d3291652b">iterNonEmptyChildIndexes</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint16_t</a> isBranch, F &amp;&amp;f) const</td></tr>
<tr class="memdesc:a00d143272df241cef3ff904d3291652b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the <code>f</code> callback for all non-empty branches.  <a href="classripple_1_1TaggedPointer.html#a00d143272df241cef3ff904d3291652b">More...</a><br /></td></tr>
<tr class="separator:a00d143272df241cef3ff904d3291652b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385d3615d8ee4a2d252bcf8bfe2bd4da"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classripple_1_1TaggedPointer.html#a385d3615d8ee4a2d252bcf8bfe2bd4da">getChildIndex</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint16_t</a> isBranch, int i) const</td></tr>
<tr class="memdesc:a385d3615d8ee4a2d252bcf8bfe2bd4da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the child's index inside the <code>hashes</code> or <code>children</code> array (which may or may not be sparse).  <a href="classripple_1_1TaggedPointer.html#a385d3615d8ee4a2d252bcf8bfe2bd4da">More...</a><br /></td></tr>
<tr class="separator:a385d3615d8ee4a2d252bcf8bfe2bd4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a4ec97fb274ad7021f7bad639cadbf42f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classripple_1_1TaggedPointer.html#a4ec97fb274ad7021f7bad639cadbf42f">destroyHashesAndChildren</a> ()</td></tr>
<tr class="memdesc:a4ec97fb274ad7021f7bad639cadbf42f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate memory and run destructors.  <a href="classripple_1_1TaggedPointer.html#a4ec97fb274ad7021f7bad639cadbf42f">More...</a><br /></td></tr>
<tr class="separator:a4ec97fb274ad7021f7bad639cadbf42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8fa030a8360a2d5085bad936e8170d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classripple_1_1TaggedPointer.html#ab8fa030a8360a2d5085bad936e8170d3">TaggedPointer</a> (<a class="el" href="structripple_1_1TaggedPointer_1_1RawAllocateTag.html">RawAllocateTag</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint8_t</a> numChildren)</td></tr>
<tr class="memdesc:ab8fa030a8360a2d5085bad936e8170d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constructor allocates space for the hashes and children, but does not run constructors.  <a href="classripple_1_1TaggedPointer.html#ab8fa030a8360a2d5085bad936e8170d3">More...</a><br /></td></tr>
<tr class="separator:ab8fa030a8360a2d5085bad936e8170d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ab40eb19b4a834bbf0316bf8b00f985f0"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uintptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classripple_1_1TaggedPointer.html#ab40eb19b4a834bbf0316bf8b00f985f0">tp_</a> = 0</td></tr>
<tr class="memdesc:ab40eb19b4a834bbf0316bf8b00f985f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upper bits are the pointer, lowest two bits are the tag A moved-from object will have a tp_ of zero.  <a href="classripple_1_1TaggedPointer.html#ab40eb19b4a834bbf0316bf8b00f985f0">More...</a><br /></td></tr>
<tr class="separator:ab40eb19b4a834bbf0316bf8b00f985f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-attribs" name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a74d9d7bb06643e18a2c6c8f4d9661393"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uintptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classripple_1_1TaggedPointer.html#a74d9d7bb06643e18a2c6c8f4d9661393">tagMask</a> = 3</td></tr>
<tr class="memdesc:a74d9d7bb06643e18a2c6c8f4d9661393"><td class="mdescLeft">&#160;</td><td class="mdescRight">bit-and with this mask to get the tag bits (lowest two bits)  <a href="classripple_1_1TaggedPointer.html#a74d9d7bb06643e18a2c6c8f4d9661393">More...</a><br /></td></tr>
<tr class="separator:a74d9d7bb06643e18a2c6c8f4d9661393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31e8ae261c16b7cd0e82a5cd9058681"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uintptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classripple_1_1TaggedPointer.html#aa31e8ae261c16b7cd0e82a5cd9058681">ptrMask</a> = ~<a class="el" href="classripple_1_1TaggedPointer.html#a74d9d7bb06643e18a2c6c8f4d9661393">tagMask</a></td></tr>
<tr class="memdesc:aa31e8ae261c16b7cd0e82a5cd9058681"><td class="mdescLeft">&#160;</td><td class="mdescRight">bit-and with this mask to get the pointer bits (mask out the tag)  <a href="classripple_1_1TaggedPointer.html#aa31e8ae261c16b7cd0e82a5cd9058681">More...</a><br /></td></tr>
<tr class="separator:aa31e8ae261c16b7cd0e82a5cd9058681"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p ><a class="el" href="classripple_1_1TaggedPointer.html" title="TaggedPointer is a combination of a pointer and a mask stored in the lowest two bits.">TaggedPointer</a> is a combination of a pointer and a mask stored in the lowest two bits. </p>
<p >Since pointers do not have arbitrary alignment, the lowest bits in the pointer are guaranteed to be zero. <a class="el" href="classripple_1_1TaggedPointer.html" title="TaggedPointer is a combination of a pointer and a mask stored in the lowest two bits.">TaggedPointer</a> stores information in these low bits. When dereferencing the pointer, these low "tag" bits are set to zero. When accessing the tag bits, the high "pointer" bits are set to zero.</p>
<p >The "pointer" part points to the equivalent to an array of <code><a class="el" href="classripple_1_1SHAMapHash.html">SHAMapHash</a></code> followed immediately by an array of <code>shared_ptr&lt;<a class="el" href="classripple_1_1SHAMapTreeNode.html">SHAMapTreeNode</a>&gt;</code>. The sizes of these arrays are determined by the tag. The tag is an index into an array (<code>boundaries</code>, defined in the cpp file) that specifies the size. Both arrays are the same size. Note that the sizes may be smaller than the full 16 elements needed to explicitly store all the children. In this case, the arrays only store the non-empty children. The non-empty children are stored in index order. For example, if only children <code>2</code> and <code>14</code> are non-empty, a two-element array would store child <code>2</code> in array index 0 and child <code>14</code> in array index 1. There are functions to convert between a child's tree index and the child's index in a sparse array.</p>
<p >The motivation for this class is saving RAM. A large percentage of inner nodes only store a small number of children. Memory can be saved by storing the inner node's children in sparse arrays. Measurements show that on average a typical <a class="el" href="classripple_1_1SHAMap.html" title="A SHAMap is both a radix tree with a fan-out of 16 and a Merkle tree.">SHAMap</a>'s inner nodes can be stored using only 25% of the original space. </p>

<p class="definition">Definition at line <a class="el" href="TaggedPointer_8h_source.html#l00059">59</a> of file <a class="el" href="TaggedPointer_8h_source.html">TaggedPointer.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab8fa030a8360a2d5085bad936e8170d3" name="ab8fa030a8360a2d5085bad936e8170d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8fa030a8360a2d5085bad936e8170d3">&#9670;&#160;</a></span>TaggedPointer() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ripple::TaggedPointer::TaggedPointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structripple_1_1TaggedPointer_1_1RawAllocateTag.html">RawAllocateTag</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint8_t</a>&#160;</td>
          <td class="paramname"><em>numChildren</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This constructor allocates space for the hashes and children, but does not run constructors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structripple_1_1TaggedPointer_1_1RawAllocateTag.html">RawAllocateTag</a></td><td>used to select overload only</td></tr>
    <tr><td class="paramname">numChildren</td><td>allocate space for at least this number of children (must be &lt;= branchFactor)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Since the hashes/children destructors are always run in the <a class="el" href="classripple_1_1TaggedPointer.html" title="TaggedPointer is a combination of a pointer and a mask stored in the lowest two bits.">TaggedPointer</a> destructor, this means those constructors <em>must</em> be run after this constructor is run. This constructor is private and only used in places where the hashes/children constructor are subsequently run. </dd></dl>

</div>
</div>
<a id="afbb502b281e5ca39f59cda1fd638e73c" name="afbb502b281e5ca39f59cda1fd638e73c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb502b281e5ca39f59cda1fd638e73c">&#9670;&#160;</a></span>TaggedPointer() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ripple::TaggedPointer::TaggedPointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7736e90fee32067aa2d91894003d37c" name="ae7736e90fee32067aa2d91894003d37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7736e90fee32067aa2d91894003d37c">&#9670;&#160;</a></span>TaggedPointer() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ripple::TaggedPointer::TaggedPointer </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint8_t</a>&#160;</td>
          <td class="paramname"><em>numChildren</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a51883d57e164a3944e03ae5b23b1af5c" name="a51883d57e164a3944e03ae5b23b1af5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51883d57e164a3944e03ae5b23b1af5c">&#9670;&#160;</a></span>TaggedPointer() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ripple::TaggedPointer::TaggedPointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classripple_1_1TaggedPointer.html">TaggedPointer</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint16_t</a>&#160;</td>
          <td class="paramname"><em>isBranch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint8_t</a>&#160;</td>
          <td class="paramname"><em>toAllocate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor is used change the number of allocated children. </p>
<p >Existing children from <code>other</code> are copied (toAllocate must be &gt;= the number of children). The motivation for making this a constructor is it saves unneeded copying and zeroing out of hashes if this were implemented directly in the <a class="el" href="classripple_1_1SHAMapInnerNode.html">SHAMapInnerNode</a> class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>children and hashes are moved from this param</td></tr>
    <tr><td class="paramname">isBranch</td><td>bitset of non-empty children in <code>other</code></td></tr>
    <tr><td class="paramname">toAllocate</td><td>allocate space for at least this number of children (must be &lt;= branchFactor) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24fb1b04da2e40a9c96f6ed3b25f46aa" name="a24fb1b04da2e40a9c96f6ed3b25f46aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24fb1b04da2e40a9c96f6ed3b25f46aa">&#9670;&#160;</a></span>TaggedPointer() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ripple::TaggedPointer::TaggedPointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classripple_1_1TaggedPointer.html">TaggedPointer</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint16_t</a>&#160;</td>
          <td class="paramname"><em>srcBranches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint16_t</a>&#160;</td>
          <td class="paramname"><em>dstBranches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint8_t</a>&#160;</td>
          <td class="paramname"><em>toAllocate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given <code>other</code> with the specified children in <code>srcBranches</code>, create a new <a class="el" href="classripple_1_1TaggedPointer.html" title="TaggedPointer is a combination of a pointer and a mask stored in the lowest two bits.">TaggedPointer</a> with the allocated number of children and the children specified in <code>dstBranches</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>children and hashes are moved from this param</td></tr>
    <tr><td class="paramname">srcBranches</td><td>bitset of non-empty children in <code>other</code></td></tr>
    <tr><td class="paramname">dstBranches</td><td>bitset of children to copy from <code>other</code> (or space to leave in a sparse array - see note below)</td></tr>
    <tr><td class="paramname">toAllocate</td><td>allocate space for at least this number of children (must be &lt;= branchFactor)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>a child may be absent in srcBranches but present in dstBranches (if dst has a sparse representation, space for the new child will be left in the sparse array). Typically, srcBranches and dstBranches will differ by at most one bit. The function works correctly if they differ by more, but there are likely more efficient algorithms to consider if this becomes a common use-case. </dd></dl>

</div>
</div>
<a id="a45086d014ec681e668f7bc3e16543ae4" name="a45086d014ec681e668f7bc3e16543ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45086d014ec681e668f7bc3e16543ae4">&#9670;&#160;</a></span>TaggedPointer() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ripple::TaggedPointer::TaggedPointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classripple_1_1TaggedPointer.html">TaggedPointer</a> const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2756e93eab705b52cba9b75666f94b05" name="a2756e93eab705b52cba9b75666f94b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2756e93eab705b52cba9b75666f94b05">&#9670;&#160;</a></span>TaggedPointer() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ripple::TaggedPointer::TaggedPointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classripple_1_1TaggedPointer.html">TaggedPointer</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace0ddb2f1b39cf44f978ec9ca5683522" name="ace0ddb2f1b39cf44f978ec9ca5683522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace0ddb2f1b39cf44f978ec9ca5683522">&#9670;&#160;</a></span>~TaggedPointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ripple::TaggedPointer::~TaggedPointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4ec97fb274ad7021f7bad639cadbf42f" name="a4ec97fb274ad7021f7bad639cadbf42f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec97fb274ad7021f7bad639cadbf42f">&#9670;&#160;</a></span>destroyHashesAndChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ripple::TaggedPointer::destroyHashesAndChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocate memory and run destructors. </p>

</div>
</div>
<a id="a824caf26851173aaf15cdb7abd9ce8b9" name="a824caf26851173aaf15cdb7abd9ce8b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824caf26851173aaf15cdb7abd9ce8b9">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classripple_1_1TaggedPointer.html">TaggedPointer</a> &amp; ripple::TaggedPointer::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classripple_1_1TaggedPointer.html">TaggedPointer</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ad8af935870774f119f6f10f7bb8274" name="a0ad8af935870774f119f6f10f7bb8274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad8af935870774f119f6f10f7bb8274">&#9670;&#160;</a></span>decode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint8_t</a>, void * &gt; ripple::TaggedPointer::decode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode the tagged pointer into its tag and pointer. </p>

</div>
</div>
<a id="aa3fcb13ead97c21651ae2ea0f60e8909" name="aa3fcb13ead97c21651ae2ea0f60e8909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3fcb13ead97c21651ae2ea0f60e8909">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint8_t</a> ripple::TaggedPointer::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of elements allocated for each array. </p>

</div>
</div>
<a id="ae529fdc057df9e07c40b488d45855b19" name="ae529fdc057df9e07c40b488d45855b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae529fdc057df9e07c40b488d45855b19">&#9670;&#160;</a></span>isDense()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ripple::TaggedPointer::isDense </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the arrays have a dense format. </p>
<dl class="section note"><dt>Note</dt><dd>The dense format is when there is an array element for all 16 (branchFactor) possible children. </dd></dl>

</div>
</div>
<a id="ac958a299ad74cb31dc778afdda884a51" name="ac958a299ad74cb31dc778afdda884a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac958a299ad74cb31dc778afdda884a51">&#9670;&#160;</a></span>getHashesAndChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std:: tuple&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint8_t</a>, <a class="el" href="classripple_1_1SHAMapHash.html">SHAMapHash</a> *, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="classripple_1_1SHAMapTreeNode.html">SHAMapTreeNode</a> &gt; * &gt; ripple::TaggedPointer::getHashesAndChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of elements in each array and a pointer to the start of each array. </p>

</div>
</div>
<a id="a7f7fe881693ea0bb3d6539f3591328f4" name="a7f7fe881693ea0bb3d6539f3591328f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f7fe881693ea0bb3d6539f3591328f4">&#9670;&#160;</a></span>getHashes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classripple_1_1SHAMapHash.html">SHAMapHash</a> * ripple::TaggedPointer::getHashes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <code>hashes</code> array. </p>

</div>
</div>
<a id="aa0b2a492f8e0a4c2e4e35d17cbd95bab" name="aa0b2a492f8e0a4c2e4e35d17cbd95bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b2a492f8e0a4c2e4e35d17cbd95bab">&#9670;&#160;</a></span>getChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="classripple_1_1SHAMapTreeNode.html">SHAMapTreeNode</a> &gt; * ripple::TaggedPointer::getChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <code>children</code> array. </p>

</div>
</div>
<a id="ac549f5187a2f29c8fb65a5a399cce913" name="ac549f5187a2f29c8fb65a5a399cce913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac549f5187a2f29c8fb65a5a399cce913">&#9670;&#160;</a></span>iterChildren()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ripple::TaggedPointer::iterChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint16_t</a>&#160;</td>
          <td class="paramname"><em>isBranch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call the <code>f</code> callback for all 16 (branchFactor) branches - even if the branch is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isBranch</td><td>bitset of non-empty children</td></tr>
    <tr><td class="paramname">f</td><td>a one parameter callback function. The parameter is the child's hash. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00d143272df241cef3ff904d3291652b" name="a00d143272df241cef3ff904d3291652b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d143272df241cef3ff904d3291652b">&#9670;&#160;</a></span>iterNonEmptyChildIndexes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ripple::TaggedPointer::iterNonEmptyChildIndexes </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint16_t</a>&#160;</td>
          <td class="paramname"><em>isBranch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call the <code>f</code> callback for all non-empty branches. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isBranch</td><td>bitset of non-empty children</td></tr>
    <tr><td class="paramname">f</td><td>a two parameter callback function. The first parameter is the branch number, the second parameter is the index into the array. For dense formats these are the same, for sparse they may be different. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a385d3615d8ee4a2d252bcf8bfe2bd4da" name="a385d3615d8ee4a2d252bcf8bfe2bd4da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385d3615d8ee4a2d252bcf8bfe2bd4da">&#9670;&#160;</a></span>getChildIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt; int &gt; ripple::TaggedPointer::getChildIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint16_t</a>&#160;</td>
          <td class="paramname"><em>isBranch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the child's index inside the <code>hashes</code> or <code>children</code> array (which may or may not be sparse). </p>
<p >The optional will be empty if an empty branch is requested and the children are sparse.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isBranch</td><td>bitset of non-empty children</td></tr>
    <tr><td class="paramname">i</td><td>index of the requested child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab40eb19b4a834bbf0316bf8b00f985f0" name="ab40eb19b4a834bbf0316bf8b00f985f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab40eb19b4a834bbf0316bf8b00f985f0">&#9670;&#160;</a></span>tp_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uintptr_t</a> ripple::TaggedPointer::tp_ = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Upper bits are the pointer, lowest two bits are the tag A moved-from object will have a tp_ of zero. </p>

<p class="definition">Definition at line <a class="el" href="TaggedPointer_8h_source.html#l00067">67</a> of file <a class="el" href="TaggedPointer_8h_source.html">TaggedPointer.h</a>.</p>

</div>
</div>
<a id="a74d9d7bb06643e18a2c6c8f4d9661393" name="a74d9d7bb06643e18a2c6c8f4d9661393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74d9d7bb06643e18a2c6c8f4d9661393">&#9670;&#160;</a></span>tagMask</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uintptr_t</a> ripple::TaggedPointer::tagMask = 3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bit-and with this mask to get the tag bits (lowest two bits) </p>

<p class="definition">Definition at line <a class="el" href="TaggedPointer_8h_source.html#l00069">69</a> of file <a class="el" href="TaggedPointer_8h_source.html">TaggedPointer.h</a>.</p>

</div>
</div>
<a id="aa31e8ae261c16b7cd0e82a5cd9058681" name="aa31e8ae261c16b7cd0e82a5cd9058681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa31e8ae261c16b7cd0e82a5cd9058681">&#9670;&#160;</a></span>ptrMask</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uintptr_t</a> ripple::TaggedPointer::ptrMask = ~<a class="el" href="classripple_1_1TaggedPointer.html#a74d9d7bb06643e18a2c6c8f4d9661393">tagMask</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bit-and with this mask to get the pointer bits (mask out the tag) </p>

<p class="definition">Definition at line <a class="el" href="TaggedPointer_8h_source.html#l00071">71</a> of file <a class="el" href="TaggedPointer_8h_source.html">TaggedPointer.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
