//------------------------------------------------------------------------------
/*
    Copyright (c) 2011-2013, OpenCoin, Inc.
*/
//==============================================================================
//
// packaging of messages into length/type-prepended buffers
// ready for transmission.

#ifndef RIPPLE_PACKEDMESSAGE_H
#define RIPPLE_PACKEDMESSAGE_H

// PackedMessage implements simple "packing" of protocol buffers Messages into
// a string prepended by a header specifying the message length.
// MessageType should be a Message class generated by the protobuf compiler.
//

class PackedMessage : public boost::enable_shared_from_this <PackedMessage>
{
public:
    typedef boost::shared_ptr< ::google::protobuf::Message > MessagePointer;
    typedef boost::shared_ptr<PackedMessage> pointer;

public:
    /** Number of bytes in a message header.
    */
    static unsigned const kHeaderBytes = 6;

    PackedMessage (::google::protobuf::Message const& message, int type);

    /** Retrieve the packed message data.
    */
    // VFALCO TODO shouldn't this be const?
    std::vector <uint8_t>& getBuffer ()
    {
        return mBuffer;
    }

    /** Determine bytewise equality.
    */
    bool operator == (PackedMessage const& other) const;

    /** Calculate the length of a packed message.
    */
    static unsigned getLength (std::vector <uint8_t> const& buf);

    /** Determine the type of a packed message.
    */
    static int getType (std::vector <uint8_t> const& buf);

private:
    // Encodes the size and type into a header at the beginning of buf
    //
    void encodeHeader (unsigned size, int type);

    std::vector <uint8_t> mBuffer;
};

#endif /* PACKEDMESSAGE_H */

