<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rippled: Fees</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rippled
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Fees </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Rippled's fee mechanism consists of several interrelated processes:</p>
<ol type="1">
<li><a href="#fee-escalation">Rapid Fee escalation</a></li>
<li><a href="#transaction-queue">The Transaction Queue</a></li>
</ol>
<h1><a class="anchor" id="autotoc_md78"></a>
Fee Escalation</h1>
<p>The guiding principal of fee escalation is that when things are going smoothly, fees stay low, but as soon as high levels of traffic appear on the network, fees will grow quickly to extreme levels. This should dissuade malicious users from abusing the system, while giving legitimate users the ability to pay a higher fee to get high-priority transactions into the open ledger, even during unfavorable conditions.</p>
<p>How fees escalate:</p>
<ol type="1">
<li>There is a base <a href="#fee-level">fee level</a> of 256, which is the minimum that a typical transaction is required to pay. For a <a href="#reference-transaction">reference transaction</a>, that corresponds to the network base fee, which is currently 10 drops.</li>
<li>However, there is a limit on the number of transactions that can get into an open ledger for that base fee level. The limit will vary based on the <a href="#consensus-health">health</a> of the consensus process, but will be at least <a href="#other-constants">5</a>.<ul>
<li>If consensus stays <a href="#consensus-health">healthy</a>, the limit will be the max of the number of transactions in the validated ledger plus <a href="#other-constants">20%</a> or the current limit until it gets to <a href="#other-constants">50</a>, at which point, the limit will be the largest number of transactions plus <a href="#other-constants">20%</a> in the last <a href="#other-constants">20</a> validated ledgers which had more than <a href="#other-constants">50</a> transactions. Any time the limit decreases (i.e. a large ledger is no longer recent), the limit will decrease to the new largest value by 10% each time the ledger has more than 50 transactions.</li>
<li>If consensus does not stay <a href="#consensus-health">healthy</a>, the limit will clamp down to the smaller of the number of transactions in the validated ledger minus <a href="#other-constants">50%</a> or the previous limit minus <a href="#other-constants">50%</a>.</li>
<li>The intended effect of these mechanisms is to allow as many base fee level transactions to get into the ledger as possible while the network is <a href="#consensus-health">healthy</a>, but to respond quickly to any condition that makes it <a href="#consensus-health">unhealthy</a>, including, but not limited to, malicious attacks.</li>
</ul>
</li>
<li>Once there are more transactions in the open ledger than indicated by the limit, the required fee level jumps drastically.<ul>
<li>The formula is <code>( lastLedgerMedianFeeLevel * TransactionsInOpenLedger^2 / limit^2 )</code>, and returns a <a href="#fee-level">fee level</a>.</li>
</ul>
</li>
<li>That may still be pretty small, but as more transactions get into the ledger, the fee level increases exponentially.<ul>
<li>For example, if the limit is 6, and the median fee is minimal, and assuming all <a href="#reference-transaction">reference transactions</a>, the 8th transaction only requires a <a href="#fee-level">level</a> of about 174,000 or about 6800 drops, but the 20th transaction requires a <a href="#fee-level">level</a> of about 1,283,000 or about 50,000 drops.</li>
</ul>
</li>
<li>Finally, as each ledger closes, the median fee level of that ledger is computed and used as <code>lastLedgerMedianFeeLevel</code> (with a <a href="#other-constants">minimum value of 128,000</a>) in the fee escalation formula for the next open ledger.<ul>
<li>Continuing the example above, if ledger consensus completes with only those 20 transactions, and all of those transactions paid the minimum required fee at each step, the limit will be adjusted from 6 to 24, and the <code>lastLedgerMedianFeeLevel</code> will be about 322,000, which is 12,600 drops for a <a href="#reference-transaction">reference transaction</a>.</li>
<li>This will only require 10 drops for the first 25 transactions, but the 26th transaction will require a level of about 349,150 or about 13,649 drops.</li>
</ul>
</li>
</ol>
<ul>
<li>This example assumes a cold-start scenario, with a single, possibly malicious, user willing to pay arbitrary amounts to get transactions into the open ledger. It ignores the effects of the <a href="#transaction-queue">Transaction Queue</a>. Any lower fee level transactions submitted by other users at the same time as this user's transactions will go into the transaction queue, and will have the first opportunity to be applied to the <em>next</em> open ledger. The next section describes how that works in more detail.</li>
</ul>
<h1><a class="anchor" id="autotoc_md79"></a>
Transaction Queue</h1>
<p>An integral part of making fee escalation work for users of the network is the transaction queue. The queue allows legitimate transactions to be considered by the network for future ledgers if the escalated open ledger fee gets too high. This allows users to submit low priority transactions with a low fee, and wait for high fees to drop. It also allows legitimate users to continue submitting transactions during high traffic periods, and give those transactions a much better chance to succeed.</p>
<ol type="1">
<li>If an incoming transaction meets both the base <a href="#fee-level">fee level</a> and the load fee minimum, but does not have a high enough <a href="#fee-level">fee level</a> to immediately go into the open ledger, it is instead put into the queue and broadcast to peers. Each peer will then make an independent decision about whether to put the transaction into its open ledger or the queue. In principle, peers with identical open ledgers will come to identical decisions. Any discrepancies will be resolved as usual during consensus.</li>
<li>When consensus completes, the open ledger limit is adjusted, and the required <a href="#fee-level">fee level</a> drops back to the base <a href="#fee-level">fee level</a>. Before the ledger is made available to external transactions, transactions are applied from the queue to the ledger from highest <a href="#fee-level">fee level</a> to lowest. These transactions count against the open ledger limit, so the required <a href="#fee-level">fee level</a> may start rising during this process.</li>
<li>Once the queue is empty, or the required <a href="#fee-level">fee level</a> rises too high for the remaining transactions in the queue, the ledger is opened up for normal transaction processing.</li>
<li>A transaction in the queue can stay there indefinitely in principle, but in practice, either<ul>
<li>it will eventually get applied to the ledger,</li>
<li>it will attempt to apply to the ledger and fail,</li>
<li>it will attempt to apply to the ledger and retry <a href="#other-constants">10 times</a>,</li>
<li>its last ledger sequence number will expire,</li>
<li>the user will replace it by submitting another transaction with the same sequence number and at least a <a href="#other-constants">25% higher fee</a>, or</li>
<li>it will get dropped when the queue fills up with more valuable transactions. The size limit is computed dynamically, and can hold transactions for the next <a href="#other-constants">20 ledgers</a> (restricted to a minimum of <a href="#other-constants">2000 transactions</a>). The lower the transaction's fee, the more likely that it will get dropped if the network is busy.</li>
</ul>
</li>
</ol>
<p>If a transaction is submitted for an account with one or more transactions already in the queue, and a sequence number that is sequential with the other transactions in the queue for that account, it will be considered for the queue if it meets these additional criteria:</p><ul>
<li>the account has fewer than <a href="#other-constants">10</a> transactions already in the queue.</li>
<li>it pays a <a href="#fee-level">fee level</a> that is greater than 10% of the fee level for the transaction with the previous sequence number,</li>
<li>all other queued transactions for that account, in the case where they spend the maximum possible XRP, leave enough XRP balance to pay the fee,</li>
<li>the total fees for the other queued transactions are less than both the network's minimum reserve and the account's XRP balance, and</li>
<li>none of the prior queued transactions affect the ability of subsequent transactions to claim a fee.</li>
</ul>
<p>Currently, there is an additional restriction that the queue cannot work with transactions using the <code>sfPreviousTxnID</code> or <code>sfAccountTxnID</code> fields. <code>sfPreviousTxnID</code> is deprecated and shouldn't be used anyway. Future development will make the queue aware of <code>sfAccountTxnID</code> mechanisms.</p>
<h1><a class="anchor" id="autotoc_md80"></a>
Technical Details</h1>
<h2><a class="anchor" id="autotoc_md81"></a>
Fee Level</h2>
<p>"Fee level" is used to allow the cost of different types of transactions to be compared directly. For a <a href="#reference-transaction">reference transaction</a>, the base fee level is 256. If a transaction is submitted with a higher <code>Fee</code> field, the fee level is scaled appropriately.</p>
<p>Examples, assuming a <a href="#reference-transaction">reference transaction</a> base fee of 10 drops:</p>
<ol type="1">
<li>A single-signed <a href="#reference-transaction">reference transaction</a> with <code>Fee=20</code> will have a fee level of <code>20 drop fee * 256 fee level / 10 drop base fee = 512 fee level</code>.</li>
<li>A multi-signed <a href="#reference-transaction">reference transaction</a> with 3 signatures (base fee = 40 drops) and <code>Fee=60</code> will have a fee level of <code>60 drop fee * 256 fee level / ((1tx + 3sigs) * 10 drop base fee) = 384 fee level</code>.</li>
<li>A hypothetical future non-reference transaction with a base fee of 15 drops multi-signed with 5 signatures and <code>Fee=90</code> will have a fee level of <code>90 drop fee * 256 fee level / ((1tx + 5sigs) * 15 drop base fee) = 256 fee level</code>.</li>
</ol>
<p>This demonstrates that a simpler transaction paying less XRP can be more likely to get into the open ledger, or be sorted earlier in the queue than a more complex transaction paying more XRP.</p>
<h2><a class="anchor" id="autotoc_md82"></a>
Reference Transaction</h2>
<p>In this document, a "Reference Transaction" is any currently implemented single-signed transaction (eg. Payment, Account Set, Offer Create, etc) that requires a fee.</p>
<p>In the future, there may be other transaction types that require more (or less) work for rippled to process. Those transactions may have a higher (or lower) base fee, requiring a correspondingly higher (or lower) fee to get into the same position as a reference transaction.</p>
<h2><a class="anchor" id="autotoc_md83"></a>
Consensus Health</h2>
<p>For consensus to be considered healthy, the consensus process must take less than 5 seconds. This time limit was chosen based on observed past behavior of the ripple network. Note that this is not necessarily the time between ledger closings, as consensus usually starts some amount of time after a ledger opens.</p>
<h2><a class="anchor" id="autotoc_md84"></a>
Other Constants</h2>
<ul>
<li><em>Base fee transaction limit per ledger</em>. The minimum value of 5 was chosen to ensure the limit never gets so small that the ledger becomes unusable. The "target" value of 50 was chosen so the limit never gets large enough to invite abuse, but keeps up if the network stays healthy and active. These exact values were chosen experimentally, and can easily change in the future.</li>
<li><em>Expected ledger size growth and reduction percentages</em>. The growth value of 20% was chosen to allow the limit to grow quickly as load increases, but not so quickly as to allow bad actors to run unrestricted. The reduction value of 50% was chosen to cause the limit to drop significantly, but not so drastically that the limit cannot quickly recover if the problem is temporary. These exact values were chosen experimentally, and can easily change in the future.</li>
<li><em>Minimum <code>lastLedgerMedianFeeLevel</code></em>. The value of 500 was chosen to ensure that the first escalated fee was more significant and noticable than what the default would allow. This exact value was chosen experimentally, and can easily change in the future.</li>
<li><em>Transaction queue size limit</em>. The limit is computed based on the base fee transaction limit per ledger, so that the queue can grow automatically as the ripple network's performance improves, allowing more transactions per second, and thus more transactions per ledger to process successfully. The limit of 20 ledgers was used to provide a balance between resource (specifically memory) usage, and giving transactions a realistic chance to be processed. The minimum size of 2000 transactions was chosen to allow a decent functional backlog during network congestion conditions. These exact values were chosen experimentally, and can easily change in the future.</li>
<li><em>Maximum retries</em>. A transaction in the queue can attempt to apply to the open ledger, but get a retry (<code>ter</code>) code up to 10 times, at which point, it will be removed from the queue and dropped. The value was chosen to be large enough to allow temporary failures to clear up, but small enough that the queue doesn't fill up with stale transactions which prevent lower fee level, but more likely to succeed, transactions from queuing.</li>
<li><em>Maximum transactions per account</em>. A single account can have up to 10 transactions in the queue at any given time. This is primarily to mitigate the lost cost of broadcasting multiple transactions if one of the earlier ones fails or is otherwise removed from the queue without being applied to the open ledger. The value was chosen arbitrarily, and can easily change in the future.</li>
<li><em>Minimum last ledger sequence buffer</em>. If a transaction has a <code>LastLedgerSequence</code> value, and cannot be processed into the open ledger, that <code>LastLedgerSequence</code> must be at least 2 more than the sequence number of the open ledger to be considered for the queue. The value was chosen to provide a balance between letting the user control the lifespan of the transaction, and giving a queued transaction a chance to get processed out of the queue before getting discarded, particularly since it may have dependent transactions also in the queue, which will never succeed if this one is discarded.</li>
<li><em>Replaced transaction fee increase</em>. Any transaction in the queue can be replaced by another transaction with the same sequence number and at least a 25% higher fee level. The 25% increase is intended to cover the resource cost incurred by broadcasting the original transaction to the network. This value was chosen experimentally, and can easily change in the future.</li>
</ul>
<h2><a class="anchor" id="autotoc_md85"></a>
&lt;tt&gt;fee&lt;/tt&gt; command</h2>
<p><b>The <code>fee</code> RPC and WebSocket command is still experimental, and may change without warning.</b></p>
<p><code>fee</code> takes no parameters, and returns information about the current local <a href="#fee-escalation">fee escalation</a> and <a href="#transaction-queue">transaction queue</a> state as both fee levels and drops. The drop values assume a single-singed reference transaction. It is up to the user to compute the neccessary fees for other types of transactions. (E.g. multiply all drop values by 5 for a multi-signed transaction with 4 signatures.)</p>
<p>The <code>fee</code> result is always instantanteous, and relates to the open ledger. It includes the sequence number of the current open ledger, but may not make sense if rippled is not synced to the network.</p>
<p>Result format: </p><div class="fragment"><div class="line">{</div>
<div class="line">   &quot;result&quot; : {</div>
<div class="line">      &quot;current_ledger_size&quot; : &quot;16&quot;, // number of transactions in the open ledger</div>
<div class="line">      &quot;current_queue_size&quot; : &quot;2&quot;, // number of transactions waiting in the queue</div>
<div class="line">      &quot;expected_ledger_size&quot; : &quot;15&quot;, // one less than the number of transactions that can get into the open ledger for the base fee.</div>
<div class="line">      &quot;max_queue_size&quot; : &quot;300&quot;, // number of transactions allowed into the queue</div>
<div class="line">      &quot;ledger_current_index&quot; : 123456789, // sequence number of the current open ledger</div>
<div class="line">      &quot;levels&quot; : {</div>
<div class="line">         &quot;reference_level&quot; : &quot;256&quot;, // level of a reference transaction. Always 256.</div>
<div class="line">         &quot;minimum_level&quot; : &quot;256&quot;, // minimum fee level to get into the queue. If &gt;256, indicates the queue is full.</div>
<div class="line">         &quot;median_level&quot; : &quot;281600&quot;, // lastLedgerMedianFeeLevel used in escalation calculations.</div>
<div class="line">         &quot;open_ledger_level&quot; : &quot;320398&quot; // minimum fee level to get into the open ledger immediately.</div>
<div class="line">      },</div>
<div class="line">      &quot;drops&quot; : {</div>
<div class="line">         &quot;base_fee&quot; : &quot;10&quot;, // base fee of a reference transaction in drops.</div>
<div class="line">         &quot;minimum_fee&quot; : &quot;10&quot;, // minimum drops to get a reference transaction into the queue. If &gt;base_fee, indicates the queue is full.</div>
<div class="line">         &quot;median_fee&quot; : &quot;11000&quot;, // drop equivalent of &quot;median_level&quot; for a reference transaction.</div>
<div class="line">         &quot;open_ledger_fee&quot; : &quot;12516&quot; // minimum drops to get a reference transaction into the open ledger immediately.</div>
<div class="line">      }</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md86"></a>
&lt;a href="https://ripple.com/build/rippled-apis/#server-info"&gt;&lt;tt&gt;server_info&lt;/tt&gt;&lt;/a&gt; command</h2>
<p><b>The fields listed here are still experimental, and may change without warning.</b></p>
<p>Up to two fields in <code>server_info</code> output are related to fee escalation.</p>
<ol type="1">
<li><code>load_factor_fee_escalation</code>: The factor on base transaction cost that a transaction must pay to get into the open ledger. This value can change quickly as transactions are processed from the network and ledgers are closed. If not escalated, the value is 1, so will not be returned.</li>
<li><code>load_factor_fee_queue</code>: If the queue is full, this is the factor on base transaction cost that a transaction must pay to get into the queue. If not full, the value is 1, so will not be returned.</li>
</ol>
<p>In all cases, the transaction fee must be high enough to overcome both <code>load_factor_fee_queue</code> and <code>load_factor</code> to be considered. It does not need to overcome <code>load_factor_fee_escalation</code>, though if it does not, it is more likely to be queued than immediately processed into the open ledger.</p>
<h2><a class="anchor" id="autotoc_md87"></a>
&lt;a href="https://ripple.com/build/rippled-apis/#server-state"&gt;&lt;tt&gt;server_state&lt;/tt&gt;&lt;/a&gt; command</h2>
<p><b>The fields listed here are still experimental, and may change without warning.</b></p>
<p>Three fields in <code>server_state</code> output are related to fee escalation.</p>
<ol type="1">
<li><code>load_factor_fee_escalation</code>: The factor on base transaction cost that a transaction must pay to get into the open ledger. This value can change quickly as transactions are processed from the network and ledgers are closed. The ratio between this value and <code>load_factor_fee_reference</code> determines the multiplier for transaction fees to get into the current open ledger.</li>
<li><code>load_factor_fee_queue</code>: This is the factor on base transaction cost that a transaction must pay to get into the queue. The ratio between this value and <code>load_factor_fee_reference</code> determines the multiplier for transaction fees to get into the transaction queue to be considered for a later ledger.</li>
<li><code>load_factor_fee_reference</code>: Like <code>load_base</code>, this is the baseline that is used to scale fee escalation computations.</li>
</ol>
<p>In all cases, the transaction fee must be high enough to overcome both <code>load_factor_fee_queue</code> and <code>load_factor</code> to be considered. It does not need to overcome <code>load_factor_fee_escalation</code>, though if it does not, it is more likely to be queued than immediately processed into the open ledger. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
