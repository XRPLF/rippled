
'use strict';

var _ = require('lodash');
var fs = require('fs');
var path = require('path');
var assert = require('assert');
var validator = require('is-my-json-valid');
var core = require('./utils').core;
var ValidationError = require('./errors').ValidationError;

var SCHEMAS = {};

function isValidAddress(address) {
  return typeof address === 'string' && address.length > 0 && address[0] === 'r' && core.UInt160.is_valid(address);
}

function isValidLedgerHash(ledgerHash) {
  return core.UInt256.is_valid(ledgerHash);
}

function loadSchema(filepath) {
  try {
    return JSON.parse(fs.readFileSync(filepath, 'utf8'));
  } catch (e) {
    throw new Error('Failed to parse schema: ' + filepath);
  }
}

function endsWith(str, suffix) {
  return str.indexOf(suffix, str.length - suffix.length) !== -1;
}

function loadSchemas(dir) {
  var filenames = fs.readdirSync(dir).filter(function (name) {
    return endsWith(name, '.json');
  });
  var schemas = filenames.map(function (name) {
    return loadSchema(path.join(dir, name));
  });
  var titles = _.map(schemas, function (schema) {
    return schema.title;
  });
  var duplicates = _.keys(_.pick(_.countBy(titles), function (count) {
    return count > 1;
  }));
  assert(duplicates.length === 0, 'Duplicate schemas for: ' + duplicates);
  return _.indexBy(schemas, 'title');
}

function formatSchemaError(error) {
  return error.field + ' ' + error.message + (error.value ? ' (' + JSON.stringify(error.value) + ')' : '');
}

function formatSchemaErrors(errors) {
  return errors.map(formatSchemaError).join(', ');
}

function schemaValidate(schemaName, object) {
  var formats = { address: isValidAddress,
    ledgerHash: isValidLedgerHash };
  var options = { schemas: SCHEMAS, formats: formats,
    verbose: true, greedy: true };
  var schema = SCHEMAS[schemaName];
  if (schema === undefined) {
    throw new Error('schema not found for: ' + schemaName);
  }
  var validate = validator(schema, options);
  var isValid = validate(object);
  if (!isValid) {
    throw new ValidationError(formatSchemaErrors(validate.errors));
  }
}

SCHEMAS = loadSchemas(path.join(__dirname, './schemas'));
module.exports = {
  schemaValidate: schemaValidate,
  isValidAddress: isValidAddress,
  loadSchema: loadSchema,
  SCHEMAS: SCHEMAS
};