'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createDecoratedClass = require('babel-runtime/helpers/create-decorated-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var elliptic = require('elliptic');
var secp256k1 = elliptic.ec('secp256k1');
var hashjs = require('hash.js');

var _require = require('./keypair');

var KeyPair = _require.KeyPair;
var KeyType = _require.KeyType;

var _require2 = require('./utils');

var Sha512 = _require2.Sha512;
var cached = _require2.cached;

function deriveScalar(bytes, discrim) {
  var order = secp256k1.curve.n;
  for (var i = 0; i <= 0xFFFFFFFF; i++) {
    // We hash the bytes to find a 256 bit number, looping until we are sure it
    // is less than the order of the curve.
    var hasher = new Sha512().add(bytes);
    // If the optional discriminator index was passed in, update the hash.
    if (discrim !== undefined) {
      hasher.addU32(discrim);
    }
    hasher.addU32(i);
    var key = hasher.first256BN();
    if (key.cmpn(0) > 0 && key.cmp(order) < 0) {
      return key;
    }
  }
  throw new Error('impossible unicorn ;)');
}

/**
* @param {Array} seed - bytes
* @param {Object} [opts] - object
* @param {Number} [opts.accountIndex=0] - the account number to generate
* @param {Boolean} [opts.validator=false] - generate root key-pair,
*                                              as used by validators.
* @return {bn.js} - 256 bit scalar value
*
*/
function deriveSecret(seed) {
  var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  var root = opts.validator;
  var order = secp256k1.curve.n;

  // This private generator represents the `root` private key, and is what's
  // used by validators for signing when a keypair is generated from a seed.
  var privateGen = deriveScalar(seed);
  if (root) {
    // As returned by validation_create for a given seed
    return privateGen;
  }
  var publicGen = secp256k1.g.mul(privateGen);
  // A seed can generate many keypairs as a function of the seed and a uint32.
  // Almost everyone just uses the first account, `0`.
  var accountIndex = opts.accountIndex || 0;
  return deriveScalar(publicGen.encodeCompressed(), accountIndex).add(privateGen).mod(order);
}

function accountPublicFromPublicGenerator(publicGenBytes) {
  var rootPubPoint = secp256k1.curve.decodePoint(publicGenBytes);
  var scalar = deriveScalar(publicGenBytes, 0);
  var point = secp256k1.g.mul(scalar);
  var offset = rootPubPoint.add(point);
  return offset.encodeCompressed();
}

var K256Pair = (function (_KeyPair) {
  _inherits(K256Pair, _KeyPair);

  function K256Pair(options) {
    _classCallCheck(this, K256Pair);

    _get(Object.getPrototypeOf(K256Pair.prototype), 'constructor', this).call(this, options);
    this.type = KeyType.secp256k1;
    this.validator = options.validator;
  }

  _createDecoratedClass(K256Pair, [{
    key: 'sign',

    /*
    @param {Array<Byte>} message (bytes)
     */
    value: function sign(message) {
      return this._createSignature(message).toDER();
    }

    /*
    @param {Array<Byte>} message - bytes
    @param {Array<Byte>} signature - DER encoded signature bytes
     */
  }, {
    key: 'verify',
    value: function verify(message, signature) {
      try {
        return this.key().verify(this.hashMessage(message), signature);
        /* eslint-disable no-catch-shadow */
      } catch (e) {
        /* eslint-enable no-catch-shadow */
        return false;
      }
    }
  }, {
    key: 'pubKeyCanonicalBytes',
    decorators: [cached],
    value: function pubKeyCanonicalBytes() {
      return this.key().getPublic().encodeCompressed();
    }
  }, {
    key: '_createSignature',
    value: function _createSignature(message) {
      return this.key().sign(this.hashMessage(message), { canonical: true });
    }

    /*
    @param {Array<Byte>} message - (bytes)
    @return {Array<Byte>} - 256 bit hash of the message
     */
  }, {
    key: 'hashMessage',
    value: function hashMessage(message) {
      return hashjs.sha512().update(message).digest().slice(0, 32);
    }
  }, {
    key: 'key',
    decorators: [cached],
    value: function key() {
      if (this.seedBytes) {
        var options = { validator: this.validator };
        return secp256k1.keyFromPrivate(deriveSecret(this.seedBytes, options));
      }
      return secp256k1.keyFromPublic(this.pubKeyCanonicalBytes());
    }
  }], [{
    key: 'fromSeed',
    value: function fromSeed(seedBytes) {
      var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      return new K256Pair({ seedBytes: seedBytes, validator: opts.validator });
    }
  }]);

  return K256Pair;
})(KeyPair);

module.exports = {
  K256Pair: K256Pair,
  accountPublicFromPublicGenerator: accountPublicFromPublicGenerator
};