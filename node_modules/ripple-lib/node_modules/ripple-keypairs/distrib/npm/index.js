'use strict';

var assert = require('assert');
var brorand = require('brorand');
var codec = require('ripple-address-codec');

var _require = require('./utils');

var seedFromPhrase = _require.seedFromPhrase;
var createAccountID = _require.createAccountID;

var _require2 = require('./keypair');

var KeyPair = _require2.KeyPair;
var KeyType = _require2.KeyType;

var _require3 = require('./ed25519');

var Ed25519Pair = _require3.Ed25519Pair;

var _require4 = require('./secp256k1');

var K256Pair = _require4.K256Pair;
var accountPublicFromPublicGenerator = _require4.accountPublicFromPublicGenerator;
var decodeSeed = codec.decodeSeed;
var encodeNodePublic = codec.encodeNodePublic;
var decodeNodePublic = codec.decodeNodePublic;
var encodeAccountID = codec.encodeAccountID;

function parseSeed(seed) {
  var type = arguments.length <= 1 || arguments[1] === undefined ? KeyType.secp256k1 : arguments[1];

  if (typeof seed !== 'string') {
    return { bytes: seed, type: type };
  }
  return decodeSeed(seed);
}

KeyPair.fromSeed = function (seed, type, options) {
  if (type === undefined) type = KeyType.secp256k1;

  if (typeof seed === 'string') {
    var decoded = decodeSeed(seed);
    var optionsArg = type;
    return this.fromSeed(decoded.bytes, decoded.type, optionsArg);
  }

  assert(type === KeyType.secp256k1 || type === KeyType.ed25519);
  var Pair = type === 'ed25519' ? Ed25519Pair : K256Pair;
  return Pair.fromSeed(seed, options);
};

function deriveWallet(seedBytes, type) {
  var pair = KeyPair.fromSeed(seedBytes, type);

  return {
    seed: pair.seed(),
    accountID: pair.accountID(),
    publicKey: pair.pubKeyHex()
  };
}

function deriveValidator(seedBytes) {
  var pair = K256Pair.fromSeed(seedBytes, { validator: true });
  return {
    seed: pair.seed(),
    publicKey: encodeNodePublic(pair.pubKeyCanonicalBytes())
  };
}

function generateWallet() {
  var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var _opts$type = opts.type;
  var type = _opts$type === undefined ? 'secp256k1' : _opts$type;
  var _opts$random = opts.random;
  var random = _opts$random === undefined ? brorand : _opts$random;

  var seedBytes = random(16);
  return deriveWallet(seedBytes, type);
}

function walletFromSeed(seed, seedType) {
  var _parseSeed = parseSeed(seed, seedType);

  var type = _parseSeed.type;
  var bytes = _parseSeed.bytes;

  return deriveWallet(bytes, type);
}

function walletFromPhrase(phrase, type) {
  return walletFromSeed(seedFromPhrase(phrase), type);
}

function generateValidatorKeys() {
  var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var _opts$random2 = opts.random;
  var random = _opts$random2 === undefined ? brorand : _opts$random2;

  return deriveValidator(random(16));
}

function nodePublicAccountID(publicKey) {
  var generatorBytes = decodeNodePublic(publicKey);
  var accountPublicBytes = accountPublicFromPublicGenerator(generatorBytes);
  return encodeAccountID(createAccountID(accountPublicBytes));
}

function validatorKeysFromSeed(seed, seedType) {
  var _parseSeed2 = parseSeed(seed, seedType);

  var type = _parseSeed2.type;
  var bytes = _parseSeed2.bytes;

  assert(type === KeyType.secp256k1);
  return deriveValidator(bytes);
}

function validatorKeysFromPhrase(phrase) {
  return deriveValidator(seedFromPhrase(phrase));
}

function keyPairFromSeed(seedString, options) {
  return KeyPair.fromSeed(seedString, options);
}

module.exports = {
  KeyPair: KeyPair,
  K256Pair: K256Pair,
  Ed25519Pair: Ed25519Pair,
  KeyType: KeyType,
  seedFromPhrase: seedFromPhrase,
  createAccountID: createAccountID,
  keyPairFromSeed: keyPairFromSeed,
  generateWallet: generateWallet,
  generateValidatorKeys: generateValidatorKeys,
  walletFromSeed: walletFromSeed,
  walletFromPhrase: walletFromPhrase,
  validatorKeysFromSeed: validatorKeysFromSeed,
  validatorKeysFromPhrase: validatorKeysFromPhrase,
  nodePublicAccountID: nodePublicAccountID
};