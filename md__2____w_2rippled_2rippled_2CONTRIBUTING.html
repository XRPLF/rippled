<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rippled: CONTRIBUTING</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">rippled
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">CONTRIBUTING</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The XRP Ledger has many and diverse stakeholders, and everyone deserves a chance to contribute meaningful changes to the code that runs the XRPL.</p>
<h1><a class="anchor" id="autotoc_md55"></a>
Contributing</h1>
<p>We assume you are familiar with the general practice of <a href="https://docs.github.com/en/get-started/quickstart/contributing-to-projects">making contributions on GitHub</a>. This file includes only special instructions specific to this project.</p>
<h2><a class="anchor" id="autotoc_md56"></a>
Before you start</h2>
<p>The following branches exist in the main project repository:</p>
<ul>
<li><code>develop</code>: The latest set of unreleased features, and the most common starting point for contributions.</li>
<li><code>release</code>: The latest beta release or release candidate.</li>
<li><code>master</code>: The latest stable release.</li>
<li><code>gh-pages</code>: The documentation for this project, built by Doxygen.</li>
</ul>
<p>The tip of each branch must be signed. In order for GitHub to sign a squashed commit that it builds from your pull request, GitHub must know your verifying key. Please set up <a href="https://docs.github.com/en/authentication/managing-commit-signature-verification/about-commit-signature-verification">signature verification</a>.</p>
<p>In general, external contributions should be developed in your personal <a href="https://github.com/XRPLF/rippled/fork">fork</a>. Contributions from developers with write permissions should be done in <a href="https://github.com/XRPLF/rippled">the main repository</a> in a branch with a permitted prefix. Permitted prefixes are:</p>
<ul>
<li>XLS-[a-zA-Z0-9]+/.+<ul>
<li>e.g. XLS-0033d/mpt-clarify-STEitherAmount</li>
</ul>
</li>
<li>[GitHub username]/.+<ul>
<li>e.g. JoelKatz/fix-rpc-webhook-queue</li>
</ul>
</li>
<li>[Organization name]/.+<ul>
<li>e.g. ripple/antithesis</li>
</ul>
</li>
</ul>
<p>Regardless of where the branch is created, please open a <em>draft</em> pull request as soon as possible after pushing the branch to Github, to increase visibility, and ease feedback during the development process.</p>
<h2><a class="anchor" id="autotoc_md57"></a>
Major contributions</h2>
<p>If your contribution is a major feature or breaking change, then you must first write an XRP Ledger Standard (XLS) describing it. Go to <a href="https://github.com/XRPLF/XRPL-Standards/discussions">XRPL-Standards</a>, choose the next available standard number, and open a discussion with an appropriate title to propose your draft standard.</p>
<p>When you submit a pull request, please link the corresponding XLS in the description. An XLS still in draft status is considered a work-in-progress and open for discussion. Please allow time for questions, suggestions, and changes to the XLS draft. It is the responsibility of the XLS author to update the draft to match the final implementation when its corresponding pull request is merged, unless the author delegates that responsibility to others.</p>
<h2><a class="anchor" id="autotoc_md58"></a>
Before making a pull request</h2>
<p>(Or marking a draft pull request as ready.)</p>
<p>Changes that alter transaction processing must be guarded by an <a href="https://xrpl.org/amendments.html">Amendment</a>. All other changes that maintain the existing behavior do not need an Amendment.</p>
<p>Ensure that your code compiles according to the build instructions in <a class="el" href="md__2____w_2rippled_2rippled_2BUILD.html">`BUILD.md`</a>.</p>
<p>Please write tests for your code. If your test can be run offline, in under 60 seconds, then it can be an automatic test run by <code>rippled --unittest</code>. Otherwise, it must be a manual test.</p>
<p>If you create new source files, they must be organized as follows:</p>
<ul>
<li>If the files are in any of the <code>libxrpl</code> modules, the headers (<code>.h</code>) must go under <code>include/xrpl</code>, and source (<code>.cpp</code>) files must go under <code>src/libxrpl</code>.</li>
<li>All other non-test files must go under <code>src/xrpld</code>.</li>
<li>All test source files must go under <code>src/test</code>.</li>
</ul>
<p>The source must be formatted according to the style guide below.</p>
<p>Header includes must be <a href=".github/scripts/levelization">levelized</a>.</p>
<p>Changes should be usually squashed down into a single commit. Some larger or more complicated change sets make more sense, and are easier to review if organized into multiple logical commits. Either way, all commits should fit the following criteria:</p>
<ul>
<li>Changes should be presented in a single commit or a logical sequence of commits. Specifically, chronological commits that simply reflect the history of how the author implemented the change, "warts and all", are not useful to reviewers.</li>
<li>Every commit should have a good message. to explain a specific aspects of the change.</li>
<li>Every commit should be signed.</li>
<li>Every commit should be well-formed (builds successfully, unit tests passing), as this helps to resolve merge conflicts, and makes it easier to use <code>git bisect</code> to find bugs.</li>
</ul>
<h3><a class="anchor" id="autotoc_md59"></a>
Good commit messages</h3>
<p>Refer to <a href="https://cbea.ms/git-commit/">"How to Write a Git Commit Message"</a> for general rules on writing a good commit message.</p>
<p>tl;dr</p>
<blockquote class="doxtable">
<p>&zwj;1. Separate subject from body with a blank line.</p><ol type="1">
<li>Limit the subject line to 50 characters.<ul>
<li>[...]shoot for 50 characters, but consider 72 the hard limit.</li>
</ul>
</li>
<li>Capitalize the subject line.</li>
<li>Do not end the subject line with a period.</li>
<li>Use the imperative mood in the subject line.<ul>
<li>A properly formed Git commit subject line should always be able to complete the following sentence: "If applied, this commit will
     _your subject line here_".</li>
</ul>
</li>
<li>Wrap the body at 72 characters.</li>
<li>Use the body to explain what and why vs. how. </li>
</ol>
</blockquote>
<p>In addition to those guidelines, please add one of the following prefixes to the subject line if appropriate.</p>
<ul>
<li><code>fix:</code> - The primary purpose is to fix an existing bug.</li>
<li><code>perf:</code> - The primary purpose is performance improvements.</li>
<li><code>refactor:</code> - The changes refactor code without affecting functionality.</li>
<li><code>test:</code> - The changes <em>only</em> affect unit tests.</li>
<li><code>docs:</code> - The changes <em>only</em> affect documentation. This can include code comments in addition to <code>.md</code> files like this one.</li>
<li><code>build:</code> - The changes <em>only</em> affect the build process, including CMake and/or Conan settings.</li>
<li><code>chore:</code> - Other tasks that don't affect the binary, but don't fit any of the other cases. e.g. formatting, git settings, updating Github Actions jobs.</li>
</ul>
<p>Whenever possible, when updating commits after the PR is open, please add the PR number to the end of the subject line. e.g. <code>test: Add unit tests for Feature X (#1234)</code>.</p>
<h2><a class="anchor" id="autotoc_md60"></a>
Pull requests</h2>
<p>In general, pull requests use <code>develop</code> as the base branch. The exceptions are</p>
<ul>
<li>Fixes and improvements to a release candidate use <code>release</code> as the base.</li>
<li>Hotfixes use <code>master</code> as the base.</li>
</ul>
<p>If your changes are not quite ready, but you want to make it easily available for preliminary examination or review, you can create a "Draft" pull request. While a pull request is marked as a "Draft", you can rebase or reorganize the commits in the pull request as desired.</p>
<p>Github pull requests are created as "Ready" by default, or you can mark a "Draft" pull request as "Ready". Once a pull request is marked as "Ready", any changes must be added as new commits. Do not force-push to a branch in a pull request under review. (This includes rebasing your branch onto the updated base branch. Use a merge operation, instead or hit the "Update branch" button at the bottom of the Github PR page.) This preserves the ability for reviewers to filter changes since their last review.</p>
<p>A pull request must obtain <b>approvals from at least two reviewers</b> before it can be considered for merge by a Maintainer. Maintainers retain discretion to require more approvals if they feel the credibility of the existing approvals is insufficient.</p>
<p>Pull requests must be merged by <a href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/about-pull-request-merges#squash-and-merge-your-commits">squash-and-merge</a> to preserve a linear history for the <code>develop</code> branch.</p>
<h3><a class="anchor" id="autotoc_md61"></a>
"Ready to merge"</h3>
<p>A pull request should only have the "Ready to merge" label added when it meets a few criteria:</p>
<ol type="1">
<li>It must have two approving reviews as described above. (Exception: PRs that are deemed "trivial" only need one approval.)</li>
<li>All CI checks must be complete and passed. (One-off failures may be acceptable if they are related to a known issue.)</li>
<li>The PR must have a good commit message.<ul>
<li>If the PR started with a good commit message, and it doesn't need to be updated, the author can indicate that in a comment.</li>
<li>Any contributor, preferably the author, can leave a comment suggesting a commit message.</li>
<li>If the author squashes and rebases the code in preparation for merge, they should also ensure the commit message(s) are updated as well.</li>
</ul>
</li>
<li>The PR branch must be up to date with the base branch (usually <code>develop</code>). This is usually accomplished by merging the base branch into the feature branch, but if the other criteria are met, the changes can be squashed and rebased on top of the base branch.</li>
<li>Finally, and most importantly, the author of the PR must positively indicate that the PR is ready to merge. That can be accomplished by adding the "Ready to merge" label if their role allows, or by leaving a comment to the effect that the PR is ready to merge.</li>
</ol>
<p>Once the "Ready to merge" label is added, a maintainer may merge the PR at any time, so don't use it lightly.</p>
<h1><a class="anchor" id="autotoc_md62"></a>
Style guide</h1>
<p>This is a non-exhaustive list of recommended style guidelines. These are not always strictly enforced and serve as a way to keep the codebase coherent rather than a set of <em>thou shalt not</em> commandments.</p>
<h2><a class="anchor" id="autotoc_md63"></a>
Formatting</h2>
<p>All code must conform to <code>clang-format</code> version 18, according to the settings in <a href="./.clang-format"><code>.clang-format</code></a>, unless the result would be unreasonably difficult to read or maintain. To demarcate lines that should be left as-is, surround them with comments like this:</p>
<div class="fragment"><div class="line">// clang-format off</div>
<div class="line">...</div>
<div class="line">// clang-format on</div>
</div><!-- fragment --><p>You can format individual files in place by running <code>clang-format -i &lt;file&gt;...</code> from any directory within this project.</p>
<p>There is a Continuous Integration job that runs clang-format on pull requests. If the code doesn't comply, a patch file that corrects auto-fixable formatting issues is generated.</p>
<p>To download the patch file:</p>
<ol type="1">
<li>Next to <code>clang-format / check (pull_request) Failing after #s</code> -&gt; click <b>Details</b> to open the details page.</li>
<li>Left menu -&gt; click <b>Summary</b></li>
<li>Scroll down to near the bottom-right under <code>Artifacts</code> -&gt; click <b>clang-format.patch</b></li>
<li>Download the zip file and extract it to your local git repository. Run <code>git apply [patch-file-name]</code>.</li>
<li>Commit and push.</li>
</ol>
<p>You can install a pre-commit hook to automatically run <code>clang-format</code> before every commit:</p>
<div class="fragment"><div class="line">pip3 install pre-commit</div>
<div class="line">pre-commit install</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md64"></a>
Contracts and instrumentation</h2>
<p>We are using <a href="https://antithesis.com/">Antithesis</a> for continuous fuzzing, and keep a copy of <a href="https://github.com/antithesishq/antithesis-sdk-cpp/">Antithesis C++ SDK</a> in <code>external/antithesis-sdk</code>. One of the aims of fuzzing is to identify bugs by finding external conditions which cause contracts violations inside <code>rippled</code>. The contracts are expressed as <code>XRPL_ASSERT</code> or <code>UNREACHABLE</code> (defined in <code><a class="el" href="instrumentation_8h_source.html">include/xrpl/beast/utility/instrumentation.h</a></code>), which are effectively (outside of Antithesis) wrappers for <code>assert(...)</code> with added name. The purpose of name is to provide contracts with stable identity which does not rely on line numbers.</p>
<p>When <code>rippled</code> is built with the Antithesis instrumentation enabled (using <code>voidstar</code> CMake option) and ran on the Antithesis platform, the contracts become <a href="https://antithesis.com/docs/using_antithesis/properties.html">test properties</a>; otherwise they are just like a regular <code>assert</code>. To learn more about Antithesis, see <a href="https://antithesis.com/docs/introduction/how_antithesis_works.html">How Antithesis Works</a> and <a href="https://antithesis.com/docs/using_antithesis/sdk/cpp/overview.html#">C++ SDK</a></p>
<p>We continue to use the old style <code>assert</code> or <code>assert(false)</code> in certain locations, where the reporting of contract violations on the Antithesis platform is either not possible or not useful.</p>
<p>For this reason:</p>
<ul>
<li>The locations where <code>assert</code> or <code>assert(false)</code> contracts should continue to be used:<ul>
<li><code>constexpr</code> functions</li>
<li>unit tests i.e. files under <code>src/test</code></li>
<li>unit tests-related modules (files under <code>beast/test</code> and <code>beast/unit_test</code>)</li>
</ul>
</li>
<li>Outside of the listed locations, do not use <code>assert</code>; use <code>XRPL_ASSERT</code> instead, giving it unique name, with the short description of the contract.</li>
<li>Outside of the listed locations, do not use <code>assert(false)</code>; use <code>UNREACHABLE</code> instead, giving it unique name, with the description of the condition being violated</li>
<li>The contract name should start with a full name (including scope) of the function, optionally a named lambda, followed by a colon <code>:</code> and a brief (typically at most five words) description. <code>UNREACHABLE</code> contracts can use slightly longer descriptions. If there are multiple overloads of the function, use common sense to balance both brevity and unambiguity of the function name. NOTE: the purpose of name is to provide stable means of unique identification of every contract; for this reason try to avoid elements which can change in some obvious refactors or when reinforcing the condition.</li>
<li>Contract description typically (except for <code>UNREACHABLE</code>) should describe the <em>expected</em> condition, as in "I assert that _expected_ is true".</li>
<li>Contract description for <code>UNREACHABLE</code> should describe the <em>unexpected</em> situation which caused the line to have been reached.</li>
<li>Example good name for an <code>UNREACHABLE</code> macro <code>"Json::operator==(Value, Value) : invalid type"</code>; example good name for an <code>XRPL_ASSERT</code> macro <code>"Json::Value::asCString : valid type"</code>.</li>
<li>Example <b>bad</b> name <code>"RFC1751::insert(char* s, int x, int start, int length) : length is greater than or equal zero"</code> (missing namespace, unnecessary full function signature, description too verbose). Good name: <code>"ripple::RFC1751::insert : minimum length"</code>.</li>
<li>In <b>few</b> well-justified cases a non-standard name can be used, in which case a comment should be placed to explain the rationale (example in <code>contract.cpp</code>)</li>
<li>Do <b>not</b> rename a contract without a good reason (e.g. the name no longer reflects the location or the condition being checked)</li>
<li>Do not use <code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::unreachable</a></code></li>
<li>Do not put contracts where they can be violated by an external condition (e.g. timing, data payload before mandatory validation etc.) as this creates bogus bug reports (and causes crashes of Debug builds)</li>
</ul>
<h2><a class="anchor" id="autotoc_md65"></a>
Unit Tests</h2>
<p>To execute all unit tests:</p>
<p><code>rippled --unittest --unittest-jobs=&lt;number of cores&gt;</code></p>
<p>(Note: Using multiple cores on a Mac M1 can cause spurious test failures. The cause is still under investigation. If you observe this problem, try specifying fewer jobs.)</p>
<p>To run a specific set of test suites:</p>
<div class="fragment"><div class="line">rippled --unittest TestSuiteName</div>
</div><!-- fragment --><p>Note: In this example, all tests with prefix <code>TestSuiteName</code> will be run, so if <code>TestSuiteName1</code> and <code>TestSuiteName2</code> both exist, then both tests will run. Alternatively, if the unit test name finds an exact match, it will stop doing partial matches, i.e. if a unit test with a title of <code>TestSuiteName</code> exists, then no other unit test will be executed, apart from <code>TestSuiteName</code>.</p>
<h2><a class="anchor" id="autotoc_md66"></a>
Avoid</h2>
<ol type="1">
<li>Proliferation of nearly identical code.</li>
<li>Proliferation of new files and classes.</li>
<li>Complex inheritance and complex OOP patterns.</li>
<li>Unmanaged memory allocation and raw pointers.</li>
<li>Macros and non-trivial templates (unless they add significant value).</li>
<li>Lambda patterns (unless these add significant value).</li>
<li>CPU or architecture-specific code unless there is a good reason to include it, and where it is used, guard it with macros and provide explanatory comments.</li>
<li>Importing new libraries unless there is a very good reason to do so.</li>
</ol>
<h2><a class="anchor" id="autotoc_md67"></a>
Seek to</h2>
<ol type="1">
<li>Extend functionality of existing code rather than creating new code.</li>
<li>Prefer readability over terseness where important logic is concerned.</li>
<li>Inline functions that are not used or are not likely to be used elsewhere in the codebase.</li>
<li>Use clear and self-explanatory names for functions, variables, structs and classes.</li>
<li>Use TitleCase for classes, structs and filenames, camelCase for function and variable names, lower case for namespaces and folders.</li>
<li>Provide as many comments as you feel that a competent programmer would need to understand what your code does.</li>
</ol>
<h1><a class="anchor" id="autotoc_md68"></a>
Maintainers</h1>
<p>Maintainers are ecosystem participants with elevated access to the repository. They are able to push new code, make decisions on when a release should be made, etc.</p>
<h2><a class="anchor" id="autotoc_md69"></a>
Adding and removing</h2>
<p>New maintainers can be proposed by two existing maintainers, subject to a vote by a quorum of the existing maintainers. A minimum of 50% support and a 50% participation is required. In the event of a tie vote, the addition of the new maintainer will be rejected.</p>
<p>Existing maintainers can resign, or be subject to a vote for removal at the behest of two existing maintainers. A minimum of 60% agreement and 50% participation are required. The XRP Ledger Foundation will have the ability, for cause, to remove an existing maintainer without a vote.</p>
<h2><a class="anchor" id="autotoc_md70"></a>
Current Maintainers</h2>
<p>Maintainers are users with maintain or admin access to the repo.</p>
<ul>
<li><a href="https://github.com/bthomee">bthomee</a> (Ripple)</li>
<li><a href="https://github.com/intelliot">intelliot</a> (Ripple)</li>
<li><a href="https://github.com/JoelKatz">JoelKatz</a> (Ripple)</li>
<li><a href="https://github.com/legleux">legleux</a> (Ripple)</li>
<li><a href="https://github.com/mankins">mankins</a> (XRP Ledger Foundation)</li>
<li><a href="https://github.com/WietseWind">WietseWind</a> (XRPL Labs + XRP Ledger Foundation)</li>
<li><a href="https://github.com/ximinez">ximinez</a> (Ripple)</li>
</ul>
<h2><a class="anchor" id="autotoc_md71"></a>
Current Code Reviewers</h2>
<p>Code Reviewers are developers who have the ability to review, approve, and in some cases merge source code changes.</p>
<ul>
<li><a href="https://github.com/a1q123456">a1q123456</a> (Ripple)</li>
<li><a href="https://github.com/Bronek">Bronek</a> (Ripple)</li>
<li><a href="https://github.com/bthomee">bthomee</a> (Ripple)</li>
<li><a href="https://github.com/ckeshava">ckeshava</a> (Ripple)</li>
<li><a href="https://github.com/dangell7">dangell7</a> (XRPL Labs)</li>
<li><a href="https://github.com/godexsoft">godexsoft</a> (Ripple)</li>
<li><a href="https://github.com/gregtatcam">gregtatcam</a> (Ripple)</li>
<li><a href="https://github.com/kuznetsss">kuznetsss</a> (Ripple)</li>
<li><a href="https://github.com/lmaisons">lmaisons</a> (Ripple)</li>
<li><a href="https://github.com/mathbunnyru">mathbunnyru</a> (Ripple)</li>
<li><a href="https://github.com/mvadari">mvadari</a> (Ripple)</li>
<li><a href="https://github.com/oleks-rip">oleks-rip</a> (Ripple)</li>
<li><a href="https://github.com/PeterChen13579">PeterChen13579</a> (Ripple)</li>
<li><a href="https://github.com/pwang200">pwang200</a> (Ripple)</li>
<li><a href="https://github.com/q73zhao">q73zhao</a> (Ripple)</li>
<li><a href="https://github.com/shawnxie999">shawnxie999</a> (Ripple)</li>
<li><a href="https://github.com/Tapanito">Tapanito</a> (Ripple)</li>
<li><a href="https://github.com/ximinez">ximinez</a> (Ripple)</li>
</ul>
<p>Developers not on this list are able and encouraged to submit feedback on pending code changes (open pull requests).</p>
<h2><a class="anchor" id="autotoc_md72"></a>
Instructions for maintainers</h2>
<p>These instructions assume you have your git upstream remotes configured to avoid accidental pushes to the main repo, and a remote group specifying both of them. e.g.</p>
<div class="fragment"><div class="line">$ git remote -v | grep upstream</div>
<div class="line">upstream        https://github.com/XRPLF/rippled.git (fetch)</div>
<div class="line">upstream        https://github.com/XRPLF/rippled.git (push)</div>
<div class="line">upstream-push   git@github.com:XRPLF/rippled.git (fetch)</div>
<div class="line">upstream-push   git@github.com:XRPLF/rippled.git (push)</div>
<div class="line"> </div>
<div class="line">$ git config remotes.upstreams</div>
<div class="line">upstream upstream-push</div>
</div><!-- fragment --><p>You can use the <a href="./bin/git/setup-upstreams.sh">setup-upstreams</a> script to set this up.</p>
<p>It also assumes you have a default gpg signing key set up in git. e.g.</p>
<div class="fragment"><div class="line">$ git config user.signingkey</div>
<div class="line">968479A1AFF927E37D1A566BB5690EEEBB952194</div>
<div class="line"># (This is github&#39;s key. Use your own.)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md73"></a>
When and how to merge pull requests</h3>
<p>The maintainer should double-check that the PR has met all the necessary criteria, and can request additional information from the owner, or additional reviews, and can always feel free to remove the "Ready to merge" label if appropriate. The maintainer has final say on whether a PR gets merged, and are encouraged to communicate and issues or concerns to other maintainers.</p>
<h4><a class="anchor" id="autotoc_md74"></a>
Most pull requests: "Squash and merge"</h4>
<p>Most pull requests don't need special handling, and can simply be merged using the "Squash and merge" button on the Github UI. Update the suggested commit message, or modify it as needed.</p>
<h4><a class="anchor" id="autotoc_md75"></a>
Slightly more complicated pull requests</h4>
<p>Some pull requests need to be pushed to <code>develop</code> as more than one commit. A PR author may <em>request</em> to merge as separate commits. They must <em>justify</em> why separate commits are needed, and <em>specify</em> how they would like the commits to be merged. If you disagree with the author, discuss it with them directly.</p>
<p>If the process is reasonable, follow it. The simplest option is to do a fast forward only merge (<code>--ff-only</code>) on the command line and push to <code>develop</code>.</p>
<p>Some examples of when separate commits are worthwhile are:</p>
<ol type="1">
<li>PRs where source files are reorganized in multiple steps.</li>
<li>PRs where the commits are mostly independent and <em>could</em> be separate PRs, but are pulled together into one PR under a commit theme or issue.</li>
<li>PRs that are complicated enough that <code>git bisect</code> would not be much help if it determined this PR introduced a problem.</li>
</ol>
<p>Either way, check that:</p>
<ul>
<li>The commits are based on the current tip of <code>develop</code>.</li>
<li>The commits are clean: No merge commits (except when reverse merging), no "[FOLD]" or "fixup!" messages.</li>
<li>All commits are signed. If the commits are not signed by the author, use <code>git commit --amend -S</code> to sign them yourself.</li>
<li>At least one (but preferably all) of the commits has the PR number in the commit message.</li>
</ul>
<p>The "Create a merge commit" and "Rebase and merge" options should be disabled in the Github UI, but if you ever find them available <b>Do not use them!</b></p>
<h3><a class="anchor" id="autotoc_md76"></a>
Releases</h3>
<p>All releases, including release candidates and betas, are handled differently from typical PRs. Most importantly, never use the Github UI to merge a release.</p>
<p>Rippled uses a linear workflow model that can be summarized as:</p>
<ol type="1">
<li>In between releases, developers work against the <code>develop</code> branch.</li>
<li>Periodically, a maintainer will build and tag a beta version from <code>develop</code>, which is pushed to <code>release</code>.<ul>
<li>Betas are usually released every two to three weeks, though that schedule can vary depending on progress, availability, and other factors.</li>
</ul>
</li>
<li>When the changes in <code>develop</code> are considered stable and mature enough to be ready to release, a release candidate (RC) is built and tagged from <code>develop</code>, and merged to <code>release</code>.<ul>
<li>Further development for that release (primarily fixes) then continues against <code>release</code>, while other development continues on <code>develop</code>. Effectively, <code>release</code> is forked from <code>develop</code>. Changes to <code>release</code> must be reverse merged to <code>develop</code>.</li>
</ul>
</li>
<li>When the candidate has passed testing and is ready for release, the final release is merged to <code>master</code>.</li>
<li>If any issues are found post-release, a hotfix / point release may be created, which is merged to <code>master</code>, and then reverse merged to <code>develop</code>.</li>
</ol>
<h4><a class="anchor" id="autotoc_md77"></a>
Betas, and the first release candidate</h4>
<p><a class="anchor" id="autotoc_md78"></a> </p><h5>Preparing the <code>develop</code> branch</h5>
<ol type="1">
<li>Optimally, the <code>develop</code> branch will be ready to go, with all relevant PRs already merged.</li>
<li>If there are any PRs pending, merge them <b>BEFORE</b> preparing the beta.<ol type="a">
<li>If only one or two PRs need to be merged, merge those PRs as normal, updating the second one, and waiting for CI to finish in between.</li>
<li><p class="startli">If there are several pending PRs, do not use the Github UI, because the delays waiting for CI in between each merge will be unnecessarily onerous. (Incidentally, this process can also be used to merge if the Github UI has issues.) Merge each PR branch directly to a <code>release-next</code> on your local machine and create a single PR, then push your branch to <code>develop</code>.</p><ol type="i">
<li>Squash the changes from each PR, one commit each (unless more are needed), being sure to sign each commit and update the commit message to include the PR number. You may be able to use a fast-forward merge for the first PR.</li>
<li>Push your branch.</li>
<li>Continue to Making the release to update the version number, etc.</li>
</ol>
<p class="startli">The workflow may look something like:</p>
</li>
</ol>
</li>
</ol>
<div class="fragment"><div class="line">git fetch --multiple upstreams user1 user2 user3 [...]</div>
<div class="line">git checkout -B release-next --no-track upstream/develop</div>
<div class="line"> </div>
<div class="line"># Only do an ff-only merge if prbranch1 is either already</div>
<div class="line"># squashed, or needs to be merged with separate commits,</div>
<div class="line"># and has no merge commits.</div>
<div class="line"># Use -S on the ff-only merge if prbranch1 isn&#39;t signed.</div>
<div class="line">git merge [-S] --ff-only user1/prbranch1</div>
<div class="line"> </div>
<div class="line">git merge --squash user2/prbranch2</div>
<div class="line">git commit -S # Use the commit message provided on the PR</div>
<div class="line"> </div>
<div class="line">git merge --squash user3/prbranch3</div>
<div class="line">git commit -S # Use the commit message provided on the PR</div>
<div class="line"> </div>
<div class="line">[...]</div>
<div class="line"> </div>
<div class="line"># Make sure the commits look right</div>
<div class="line">git log --show-signature &quot;upstream/develop..HEAD&quot;</div>
<div class="line"> </div>
<div class="line">git push --set-upstream origin</div>
<div class="line"> </div>
<div class="line"># Continue to &quot;Making the release&quot; to update the version number, so</div>
<div class="line"># everything can be done in one PR.</div>
</div><!-- fragment --><p>You can also use the <a href="./bin/git/squash-branches.sh">squash-branches</a> script.</p>
<p>You may also need to manually close the open PRs after the changes are merged to <code>develop</code>. Be sure to include the commit ID.</p>
<p><a class="anchor" id="autotoc_md79"></a> </p><h5>Making the release</h5>
<p>This includes, betas, and the first release candidate (RC).</p>
<ol type="1">
<li>If you didn't create one preparing the `develop` branch, Ensure there is no old <code>release-next</code> branch hanging around. Then make a <code>release-next</code> branch that only changes the version number. e.g.</li>
</ol>
<div class="fragment"><div class="line">git fetch upstreams</div>
<div class="line"> </div>
<div class="line">git checkout --no-track -B release-next upstream/develop</div>
<div class="line"> </div>
<div class="line">v=&quot;A.B.C-bD&quot;</div>
<div class="line">build=$( find -name BuildInfo.cpp )</div>
<div class="line">sed &#39;s/\&zwj;(^.*versionString =\&zwj;).*$/\1 &quot;&#39;${v}&#39;&quot;/&#39; ${build} &gt; version.cpp &amp;&amp; mv -vi version.cpp ${build}</div>
<div class="line"> </div>
<div class="line">git diff</div>
<div class="line"> </div>
<div class="line">git add ${build}</div>
<div class="line"> </div>
<div class="line">git commit -S -m &quot;Set version to ${v}&quot;</div>
<div class="line"> </div>
<div class="line"># You could use your &quot;origin&quot; repo, but some CI tests work better on upstream.</div>
<div class="line">git push upstream-push</div>
<div class="line">git fetch upstreams</div>
<div class="line">git branch --set-upstream-to=upstream/release-next</div>
</div><!-- fragment --><p>You can also use the <a href="./bin/git/update-version.sh">update-version</a> script. 2. Create a Pull Request for <code>release-next</code> with **<code>develop</code>** as the base branch.</p>
<ol type="1">
<li>Use the title "[TRIVIAL] Set version to X.X.X-bX".</li>
<li>Instead of the default description template, use the following:</li>
</ol>
<div class="fragment"><div class="line">## High Level Overview of Change</div>
<div class="line"> </div>
<div class="line">This PR only changes the version number. It will be merged as</div>
<div class="line">soon as Github CI actions successfully complete.</div>
</div><!-- fragment --><ol type="1">
<li>Wait for CI to successfully complete, and get someone to approve the PR. (It is safe to ignore known CI issues.)</li>
<li>Push the updated <code>develop</code> branch using your <code>release-next</code> branch. <b>Do not use the Github UI. It's important to preserve commit IDs.</b></li>
</ol>
<div class="fragment"><div class="line">git push upstream-push release-next:develop</div>
</div><!-- fragment --><ol type="1">
<li>In the unlikely event that the push fails because someone has merged something else in the meantime, rebase your branch onto the updated <code>develop</code> branch, push again, and go back to step 3.</li>
<li>Ensure that your PR against <code>develop</code> is closed. Github should do it automatically.</li>
<li>Once this is done, forward progress on <code>develop</code> can continue (other PRs may be merged).</li>
<li>Now create a Pull Request for <code>release-next</code> with **<code>release</code>** as the base branch. Instead of the default template, reuse and update the message from the previous release. Include the following verbiage somewhere in the description:</li>
</ol>
<div class="fragment"><div class="line">The base branch is `release`. [All releases (including</div>
<div class="line">betas)](https://github.com/XRPLF/rippled/blob/develop/CONTRIBUTING.md#before-you-start)</div>
<div class="line">go in `release`. This PR branch will be pushed directly to `release` (not</div>
<div class="line">squashed or rebased, and not using the GitHub UI).</div>
</div><!-- fragment --><ol type="1">
<li>Sign-offs for the three platforms (Linux, Mac, Windows) usually occur offline, but at least one approval will be needed on the PR.<ul>
<li>If issues are discovered during testing, simply abandon the release. It's easy to start a new release, it should be easy to abandon one. <b>DO NOT REUSE THE VERSION NUMBER.</b> e.g. If you abandon 2.4.0-b1, the next attempt will be 2.4.0-b2.</li>
</ul>
</li>
<li>Once everything is ready to go, push to <code>release</code>.</li>
</ol>
<div class="fragment"><div class="line">git fetch upstreams</div>
<div class="line"> </div>
<div class="line"># Just to be safe, do a dry run first:</div>
<div class="line">git push --dry-run upstream-push release-next:release</div>
<div class="line"> </div>
<div class="line"># If everything looks right, push the branch</div>
<div class="line">git push upstream-push release-next:release</div>
<div class="line"> </div>
<div class="line"># Check that all of the branches are updated</div>
<div class="line">git fetch upstreams</div>
<div class="line">git log -1 --oneline</div>
<div class="line"># The output should look like:</div>
<div class="line"># 0123456789 (HEAD -&gt; upstream/release-next, upstream/release,</div>
<div class="line">#            upstream/develop) Set version to 2.4.0-b1</div>
<div class="line"># Note that upstream/develop may not be on this commit, but</div>
<div class="line"># upstream/release must be.</div>
<div class="line"># Other branches, including some from upstream-push, may also be</div>
<div class="line"># present.</div>
</div><!-- fragment --><ol type="1">
<li>Tag the release, too.</li>
</ol>
<div class="fragment"><div class="line">git tag &lt;version number&gt;</div>
<div class="line">git push upstream-push &lt;version number&gt;</div>
</div><!-- fragment --><ol type="1">
<li>Delete the <code>release-next</code> branch on the repo. Use the Github UI or:</li>
</ol>
<div class="fragment"><div class="line">git push --delete upstream-push release-next</div>
</div><!-- fragment --><ol type="1">
<li>Finally <a href="https://github.com/XRPLF/rippled/releases">create a new release on Github</a>.</li>
</ol>
<h4><a class="anchor" id="autotoc_md80"></a>
Release candidates after the first</h4>
<p>Once the first release candidate is merged into release, then <code>release</code> and <code>develop</code> <em>are allowed to diverge</em>.</p>
<p>If a bug or issue is discovered in a version that has a release candidate being tested, any fix and new version will need to be applied against <code>release</code>, then reverse-merged to <code>develop</code>. This helps keep git history as linear as possible.</p>
<p>A <code>release-next</code> branch will be created from <code>release</code>, and any further work for that release must be based on <code>release-next</code>. Specifically, PRs must use <code>release-next</code> as the base, and those PRs will be merged directly to <code>release-next</code> when approved. Changes should be restricted to bug fixes, but other changes may be necessary from time to time.</p>
<ol type="1">
<li>Open any PRs for the pending release using <code>release-next</code> as the base, so they can be merged directly in to it. Unlike <code>develop</code>, though, <code>release-next</code> can be thrown away and recreated if necessary.</li>
<li>Once a new release candidate is ready, create a version commit as in step 1 above on <code>release-next</code>. You can use the <a href="./bin/git/update-version.sh">update-version</a> script for this, too.</li>
<li>Jump to step 8 ("Now create a Pull Request for `release-next` with
   **`release`** as the base") from the process above to merge <code>release-next</code> into <code>release</code>.</li>
</ol>
<p><a class="anchor" id="autotoc_md81"></a> </p><h5>Follow up: reverse merge</h5>
<p>Once the RC is merged and tagged, it needs to be reverse merged into <code>develop</code> as soon as possible.</p>
<ol type="1">
<li>Create a branch, based on <code>upstream/develop</code>. The branch name is not important, but could include "mergeNNNrcN". E.g. For release A.B.C-rcD, use <code>mergeABCrcD</code>.</li>
</ol>
<div class="fragment"><div class="line">git fetch upstreams</div>
<div class="line"> </div>
<div class="line">git checkout --no-track -b mergeABCrcD upstream/develop</div>
</div><!-- fragment --><ol type="1">
<li>Merge <code>release</code> into your branch.</li>
</ol>
<div class="fragment"><div class="line"># I like the &quot;--edit --log --verbose&quot; parameters, but they are</div>
<div class="line"># not required.</div>
<div class="line">git merge upstream/release</div>
</div><!-- fragment --><ol type="1">
<li><code><a class="el" href="BuildInfo_8cpp_source.html">BuildInfo.cpp</a></code> will have a conflict with the version number. Resolve it with the version from <code>develop</code> - the higher version.</li>
<li>Push your branch to your repo (or <code>upstream</code> if you have permission), and open a normal PR against <code>develop</code>. The "High level overview" can simply indicate that this is a merge of the RC. The "Context" should summarize the changes from the RC. Include the following text prominently:</li>
</ol>
<div class="fragment"><div class="line">This PR must be merged manually using a push. Do not use the Github UI.</div>
</div><!-- fragment --><ol type="1">
<li>Depending on the complexity of the changes, and/or merge conflicts, the PR may need a thorough review, or just a sign-off that the merge was done correctly.</li>
<li>If <code>develop</code> is updated before this PR is merged, do not merge <code>develop</code> back into your branch. Instead rebase preserving merges, or do the merge again. (See also the <code>rerere</code> git config setting.)</li>
</ol>
<div class="fragment"><div class="line">git rebase --rebase-merges upstream/develop</div>
<div class="line"># OR</div>
<div class="line">git reset --hard upstream/develop</div>
<div class="line">git merge upstream/release</div>
</div><!-- fragment --><ol type="1">
<li>When the PR is ready, push it to <code>develop</code>.</li>
</ol>
<div class="fragment"><div class="line">git fetch upstreams</div>
<div class="line"> </div>
<div class="line"># Make sure the commits look right</div>
<div class="line">git log --show-signature &quot;upstream/develop^..HEAD&quot;</div>
<div class="line"> </div>
<div class="line">git push upstream-push mergeABCrcD:develop</div>
<div class="line"> </div>
<div class="line">git fetch upstreams</div>
</div><!-- fragment --><p>Development on <code>develop</code> can proceed as normal.</p>
<h4><a class="anchor" id="autotoc_md82"></a>
Final releases</h4>
<p>A final release is any release that is not a beta or RC, such as 2.2.0.</p>
<p>Only code that has already been tested and vetted across all three platforms should be included in a final release. Most of the time, that means that the commit immediately preceding the commit setting the version number will be an RC. Occasionally, there may be last-minute bug fixes included as well. If so, those bug fixes must have been tested internally as if they were RCs (at minimum, ensuring unit tests pass, and the app starts, syncs, and stops cleanly across all three platforms.)</p>
<p><em>If in doubt, make an RC first.</em></p>
<p>The process for building a final release is very similar to the process for building a beta, except the code will be moving from <code>release</code> to <code>master</code> instead of from <code>develop</code> to <code>release</code>, and both branches will be pushed at the same time.</p>
<ol type="1">
<li>Ensure there is no old <code>master-next</code> branch hanging around. Then make a <code>master-next</code> branch that only changes the version number. As above, or using the <a href="./bin/git/update-version.sh">update-version</a> script.</li>
<li>Create a Pull Request for <code>master-next</code> with **<code>master</code>** as the base branch. Instead of the default template, reuse and update the message from the previous final release. Include the following verbiage somewhere in the description:</li>
</ol>
<div class="fragment"><div class="line">The base branch is `master`. This PR branch will be pushed directly to</div>
<div class="line">`release` and `master` (not squashed or rebased, and not using the</div>
<div class="line">GitHub UI).</div>
</div><!-- fragment --><ol type="1">
<li>Sign-offs for the three platforms (Linux, Mac, Windows) usually occur offline, but at least one approval will be needed on the PR.<ul>
<li>If issues are discovered during testing, close the PR, delete <code>master-next</code>, and move development back to <code>release</code>, issuing more RCs as necessary</li>
</ul>
</li>
<li>Once everything is ready to go, push to <code>release</code> and <code>master</code>.</li>
</ol>
<div class="fragment"><div class="line">git fetch upstreams</div>
<div class="line"> </div>
<div class="line"># Just to be safe, do dry runs first:</div>
<div class="line">git push --dry-run upstream-push master-next:release</div>
<div class="line">git push --dry-run upstream-push master-next:master</div>
<div class="line"> </div>
<div class="line"># If everything looks right, push the branch</div>
<div class="line">git push upstream-push master-next:release</div>
<div class="line">git push upstream-push master-next:master</div>
<div class="line"> </div>
<div class="line"># Check that all of the branches are updated</div>
<div class="line">git fetch upstreams</div>
<div class="line">git log -1 --oneline</div>
<div class="line"># The output should look like:</div>
<div class="line"># 0123456789 (HEAD -&gt; upstream/master-next, upstream/master,</div>
<div class="line">#            upstream/release) Set version to A.B.0</div>
<div class="line"># Note that both upstream/release and upstream/master must be on this</div>
<div class="line"># commit.</div>
<div class="line"># Other branches, including some from upstream-push, may also be</div>
<div class="line"># present.</div>
</div><!-- fragment --><ol type="1">
<li>Tag the release, too.</li>
</ol>
<div class="fragment"><div class="line">git tag &lt;version number&gt;</div>
<div class="line">git push upstream-push &lt;version number&gt;</div>
</div><!-- fragment --><ol type="1">
<li>Delete the <code>master-next</code> branch on the repo. Use the Github UI or:</li>
</ol>
<div class="fragment"><div class="line">git push --delete upstream-push master-next</div>
</div><!-- fragment --><ol type="1">
<li><a href="https://github.com/XRPLF/rippled/releases">Create a new release on Github</a>. Be sure that "Set as the latest release" is checked.</li>
<li>Finally reverse merge the release into `develop`.</li>
</ol>
<h4><a class="anchor" id="autotoc_md83"></a>
Special cases: point releases, hotfixes, etc.</h4>
<p>On occassion, a bug or issue is discovered in a version that already had a final release. Most of the time, development will have started on the next version, and will usually have changes in <code>develop</code> and often in <code>release</code>.</p>
<p>Because git history is kept as linear as possible, any fix and new version will need to be applied against <code>master</code>.</p>
<p>The process for building a hotfix release is very similar to [the process for building release candidates after the first](#release-candidates-after-the-first) and for building a final release, except the changes will be done against <code>master</code> instead of <code>release</code>.</p>
<p>If there is only a single issue for the hotfix, the work can be done in any branch. When it's ready to merge, jump to step 3 using your branch instead of <code>master-next</code>.</p>
<ol type="1">
<li>Create a <code>master-next</code> branch from <code>master</code>.</li>
</ol>
<div class="fragment"><div class="line">git checkout --no-track -b master-next upstream/master</div>
<div class="line">git push upstream-push</div>
<div class="line">git fetch upstreams</div>
</div><!-- fragment --><ol type="1">
<li>Open any PRs for the pending hotfix using <code>master-next</code> as the base, so they can be merged directly in to it. Unlike <code>develop</code>, though, <code>master-next</code> can be thrown away and recreated if necessary.</li>
<li>Once the hotfix is ready, create a version commit using the same steps as above, or use the <a href="./bin/git/update-version.sh">update-version</a> script.</li>
<li>Create a Pull Request for <code>master-next</code> with **<code>master</code>** as the base branch. Instead of the default template, reuse and update the message from the previous final release. Include the following verbiage somewhere in the description:</li>
</ol>
<div class="fragment"><div class="line">The base branch is `master`. This PR branch will be pushed directly to</div>
<div class="line">`master` (not squashed or rebased, and not using the GitHub UI).</div>
</div><!-- fragment --><ol type="1">
<li>Sign-offs for the three platforms (Linux, Mac, Windows) usually occur offline, but at least one approval will be needed on the PR.<ul>
<li>If issues are discovered during testing, update <code>master-next</code> as needed, but ensure that the changes are properly squashed, and the version setting commit remains last</li>
</ul>
</li>
<li>Once everything is ready to go, push to <code>master</code> <b>only</b>.</li>
</ol>
<div class="fragment"><div class="line">git fetch upstreams</div>
<div class="line"> </div>
<div class="line"># Just to be safe, do a dry run first:</div>
<div class="line">git push --dry-run upstream-push master-next:master</div>
<div class="line"> </div>
<div class="line"># If everything looks right, push the branch</div>
<div class="line">git push upstream-push master-next:master</div>
<div class="line"> </div>
<div class="line"># Check that all of the branches are updated</div>
<div class="line">git fetch upstreams</div>
<div class="line">git log -1 --oneline</div>
<div class="line"># The output should look like:</div>
<div class="line"># 0123456789 (HEAD -&gt; upstream/master-next, upstream/master) Set version</div>
<div class="line">#            to 2.4.1</div>
<div class="line"># Note that upstream/master must be on this commit. upstream/release and</div>
<div class="line"># upstream/develop should not.</div>
<div class="line"># Other branches, including some from upstream-push, may also be</div>
<div class="line"># present.</div>
</div><!-- fragment --><ol type="1">
<li>Tag the release, too.</li>
</ol>
<div class="fragment"><div class="line">git tag &lt;version number&gt;</div>
<div class="line">git push upstream-push &lt;version number&gt;</div>
</div><!-- fragment --><ol type="1">
<li>Delete the <code>master-next</code> branch on the repo.</li>
</ol>
<div class="fragment"><div class="line">git push --delete upstream-push master-next</div>
</div><!-- fragment --><ol type="1">
<li><a href="https://github.com/XRPLF/rippled/releases">Create a new release on Github</a>. Be sure that "Set as the latest release" is checked.</li>
</ol>
<p>Once the hotfix is released, it needs to be reverse merged into <code>develop</code> as soon as possible. It may also need to be merged into <code>release</code> if a release candidate is under development.</p>
<ol type="1">
<li>Create a branch in your own repo, based on <code>upstream/develop</code>. The branch name is not important, but could include "mergeNNN". E.g. For release 2.2.3, use <code>merge223</code>.</li>
</ol>
<div class="fragment"><div class="line">git fetch upstreams</div>
<div class="line"> </div>
<div class="line">git checkout --no-track -b merge223 upstream/develop</div>
</div><!-- fragment --><ol type="1">
<li>Merge master into your branch.</li>
</ol>
<div class="fragment"><div class="line"># I like the &quot;--edit --log --verbose&quot; parameters, but they are</div>
<div class="line"># not required.</div>
<div class="line">git merge upstream/master</div>
</div><!-- fragment --><ol type="1">
<li><code><a class="el" href="BuildInfo_8cpp_source.html">BuildInfo.cpp</a></code> will have a conflict with the version number. Resolve it with the version from <code>develop</code> - the higher version.</li>
<li>Push your branch to your repo, and open a normal PR against <code>develop</code>. The "High level overview" can simply indicate that this is a merge of the hotfix version. The "Context" should summarize the changes from the hotfix. Include the following text prominently:</li>
</ol>
<div class="fragment"><div class="line">This PR must be merged manually using a --ff-only merge. Do not use the Github UI.</div>
</div><!-- fragment --><ol type="1">
<li>Depending on the complexity of the hotfix, and/or merge conflicts, the PR may need a thorough review, or just a sign-off that the merge was done correctly.</li>
<li>If <code>develop</code> is updated before this PR is merged, do not merge <code>develop</code> back into your branch. Instead rebase preserving merges, or do the merge again. (See also the <code>rerere</code> git config setting.)</li>
</ol>
<div class="fragment"><div class="line">git rebase --rebase-merges upstream/develop</div>
<div class="line"># OR</div>
<div class="line">git reset --hard upstream/develop</div>
<div class="line">git merge upstream/master</div>
</div><!-- fragment --><ol type="1">
<li>When the PR is ready, push it to <code>develop</code>.</li>
</ol>
<div class="fragment"><div class="line">git fetch upstreams</div>
<div class="line"> </div>
<div class="line"># Make sure the commits look right</div>
<div class="line">git log --show-signature &quot;upstream/develop..HEAD&quot;</div>
<div class="line"> </div>
<div class="line">git push upstream-push HEAD:develop</div>
</div><!-- fragment --><p>Development on <code>develop</code> can proceed as normal. It is recommended to create a beta (or RC) immediately to ensure that everything worked as expected.</p>
<p><a class="anchor" id="autotoc_md84"></a> </p><h5>An even rarer scenario: A hotfix on an old release</h5>
<p>Historically, once a final release is tagged and packages are released, versions older than the latest final release are no longer supported. However, there is a possibility that a very high severity bug may occur in a non-amendment blocked version that is still being run by a significant fraction of users, which would necessitate a hotfix / point release to that version as well as any later versions.</p>
<p>This scenario would follow the same basic procedure as above, except that <em>none</em> of <code>develop</code>, <code>release</code>, or <code>master</code> would be touched during the release process.</p>
<p>In this example, consider if version 2.1.1 needed to be patched.</p>
<ol type="1">
<li>Create two branches in the main (<code>upstream</code>) repo.</li>
</ol>
<div class="fragment"><div class="line">git fetch upstreams</div>
<div class="line"> </div>
<div class="line"># Create a base branch off the tag</div>
<div class="line">git checkout --no-track -b master-2.1.2 2.1.1</div>
<div class="line">git push upstream-push</div>
<div class="line"> </div>
<div class="line"># Create a working branch</div>
<div class="line">git checkout --no-track -b master212-next master-2.1.2</div>
<div class="line">git push upstream-push</div>
<div class="line"> </div>
<div class="line">git fetch upstreams</div>
</div><!-- fragment --><ol type="1">
<li>Work continues as above, except using <code>master-2.1.2</code>as the base branch for any merging, packaging, etc.</li>
<li>After the release is tagged and packages are built, you could potentially delete both branches, e.g. <code>master-2.1.2</code> and <code>master212-next</code>. However, it may be useful to keep <code>master-2.1.2</code> around indefinitely for reference.</li>
<li>Assuming that a hotfix is also released for the latest version in parallel with this one, or if the issue is already fixed in the latest version, do no do any reverse merges. However, if it is not, it probably makes sense to reverse merge <code>master-2.1.2</code> into <code>master</code>, release a hotfix for <em>that</em> version, then reverse merge from <code>master</code> to <code>develop</code>. (Please don't do this unless absolutely necessary.) </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
