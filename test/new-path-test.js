// Generated by CoffeeScript 1.4.0
(function() {
  var A0, Amount, Base, LedgerState, PathFind, Remote, Seed, Server, TestAccount, Transaction, UInt160, assert, assert_match, async, config, create_path_test, create_shorthand, deep_eq, define_suites, definer_factory, ensure_list, expand_alternative, extend, fs, gather_path_definers, path_finding_cases, path_finding_cases_string, pretty_json, prettyj, propagater, refute, simple_assert, sjcl, skip_or_only, suite_factory, test_accounts, test_alternatives_factory, testutils, _ref, _ref1;

  extend = require('extend');

  fs = require('fs');

  async = require('async');

  deep_eq = require('deep-equal');

  _ref = require('ripple-lib'), Amount = _ref.Amount, Remote = _ref.Remote, Seed = _ref.Seed, Base = _ref.Base, Transaction = _ref.Transaction, PathFind = _ref.PathFind, sjcl = _ref.sjcl, UInt160 = _ref.UInt160;

  testutils = require('./testutils');

  Server = require('./server').Server;

  _ref1 = require('./ledger-state'), LedgerState = _ref1.LedgerState, TestAccount = _ref1.TestAccount;

  test_accounts = require('./random-test-addresses').test_accounts;

  simple_assert = require('assert');

  "The tests are written in a declarative style:\n  \n  Each case has an entry in the `path_finding_cases` object\n  The key translates to a `suite(key, {...})`\n  The `{...}` passed in is compiled into a setup/teardown for the `ledger` and\n  into a bunch of `test` invokations for the `paths_expected`\n    \n    - aliases are used throughout for easier reading\n\n      - test account addresses will be created `on the fly`\n         \n         no need to declare in testconfig.js\n         debugged responses from the server substitute addresses for aliases\n\n    - The fixtures are setup just once for each ledger, multiple path finding\n      tests can be executed\n     \n    - `paths_expected` top level keys are group names\n                       2nd level keys are path test declarations\n                       \n                       test declaration keys can be suffixed meaningfully with\n                       \n                          `_skip`\n                          `_only`\n                          \n                        test declaration values can set\n                        \n                          debug: true\n                          \n                            Will dump the path declaration and \n                            translated request and subsequent response\n\n    - hops in `alternatives[*][paths][*]` can be written in shorthand\n        eg.\n          ABC/G3|G3\n            get `ABC/G3` through `G3`\n\n          ABC/M1|M1\n            get `ABC/M1` through `M1`\n\n          XRP|$\n            get `XRP` through `$` \n                              $ signifies an order book rather than account\n  \n  ------------------------------------------------------------------------------\n  Tests can be written in the 'path-tests.json' file in same directory     # <--\n  ------------------------------------------------------------------------------";


  assert = simple_assert;

  refute = function(cond, msg) {
    return assert(!cond, msg);
  };

  prettyj = pretty_json = function(v) {
    return JSON.stringify(v, void 0, 2);
  };

  propagater = function(done) {
    return function(f) {
      return function() {
        if (done.aborted) {
          return;
        }
        try {
          return f.apply(null, arguments);
        } catch (e) {
          done.aborted = true;
          throw e;
        }
      };
    };
  };

  assert_match = function(o, key_vals, message) {
    var k, v, _results;
    "assert_match path[i], matcher,\n             \"alternative[" + ai + "].paths[" + pi + "]\"";
    _results = [];
    for (k in key_vals) {
      v = key_vals[k];
      _results.push(assert.equal(o[k], v, message));
    }
    return _results;
  };

  config = testutils.init_config();

  expand_alternative = function(alt) {
    "\nMake explicit the currency and issuer in each hop in paths_computed\n";

    var amt, hop, hop_i, path, prev_currency, prev_issuer, _i, _j, _len, _len1, _ref2;
    amt = Amount.from_json(alt.source_amount);
    _ref2 = alt.paths_computed;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      path = _ref2[_i];
      prev_issuer = amt.issuer().to_json();
      prev_currency = amt.currency().to_json();
      for (hop_i = _j = 0, _len1 = path.length; _j < _len1; hop_i = ++_j) {
        hop = path[hop_i];
        if (!(hop.currency != null)) {
          hop.currency = prev_currency;
        }
        if (!(hop.issuer != null) && hop.currency !== 'XRP') {
          if (hop.account != null) {
            hop.issuer = hop.account;
          } else {
            hop.issuer = prev_issuer;
          }
        }
        if (hop.type & 0x10) {
          prev_currency = hop.currency;
        }
        if (hop.type & 0x20) {
          prev_issuer = hop.issuer;
        } else if (hop.account != null) {
          prev_issuer = hop.account;
        }
      }
    }
    return alt;
  };

  create_shorthand = function(alternatives) {
    "\nConvert explicit paths_computed into the format used by `paths_expected`\nThese can be pasted in as the basis of tests.\n";

    var alt, amt, hop, node, path, short_alt, short_path, shorthand, _i, _j, _k, _len, _len1, _len2, _ref2;
    shorthand = [];
    for (_i = 0, _len = alternatives.length; _i < _len; _i++) {
      alt = alternatives[_i];
      short_alt = {};
      shorthand.push(short_alt);
      amt = Amount.from_json(alt.source_amount);
      if (amt.is_native()) {
        short_alt.amount = amt.to_human();
        if (!(~short_alt.amount.search('.'))) {
          short_alt.amount = short_alt.amount + '.0';
        }
      } else {
        short_alt.amount = amt.to_text_full();
      }
      short_alt.paths = [];
      _ref2 = alt.paths_computed;
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        path = _ref2[_j];
        short_path = [];
        short_alt.paths.push(short_path);
        for (_k = 0, _len2 = path.length; _k < _len2; _k++) {
          node = path[_k];
          hop = node.currency;
          if (node.issuer != null) {
            hop = "" + hop + "/" + node.issuer;
          }
          hop = "" + hop + "|" + (node.account != null ? node.account : "$");
          short_path.push(hop);
        }
      }
    }
    return shorthand;
  };

  ensure_list = function(v) {
    if (Array.isArray(v)) {
      return v;
    } else {
      return [v];
    }
  };

  test_alternatives_factory = function(realias_pp, realias_text) {
    "\nWe are using a factory to create `test_alternatives` because it needs the \nper ledger `realias_*` functions\n";

    var amounts, amounts_text, check_for_no_redundant_paths, hop_matcher, match_path, simple_match_path, test_alternatives;
    hop_matcher = function(decl_hop) {
      var c, ci, f, i, is_account, matcher, _ref2, _ref3;
      _ref2 = decl_hop.split('|'), ci = _ref2[0], f = _ref2[1];
      if (!(f != null)) {
        throw new Error("No `|` in " + decl_hop);
      }
      _ref3 = ci.split('/'), c = _ref3[0], i = _ref3[1];
      is_account = f === '$' ? false : true;
      matcher = {
        currency: c
      };
      if (i != null) {
        matcher.issuer = i;
      }
      if (is_account) {
        matcher.account = f;
      }
      return matcher;
    };
    match_path = function(test, path, ai, pi) {
      var hop, i, matcher, _i, _len;
      test = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = test.length; _i < _len; _i++) {
          hop = test[_i];
          _results.push(hop_matcher(hop));
        }
        return _results;
      })();
      assert.equal(path.length, test.length, "alternative[" + ai + "] path[" + pi + "] expecting " + test.length + " hops");
      for (i = _i = 0, _len = test.length; _i < _len; i = ++_i) {
        matcher = test[i];
        assert_match(path[i], matcher, "alternative[" + ai + "].paths[" + pi + "]");
      }
    };
    simple_match_path = function(test, path, ai, pi) {
      "\n  @test\n\n    A shorthand specified path\n\n  @path\n    \n    A path as returned by the server with `expand_alternative` done\n    so issuer and currency are always stated.\n";

      var hop, i, k, matcher, v, _i, _len;
      test = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = test.length; _i < _len; _i++) {
          hop = test[_i];
          _results.push(hop_matcher(hop));
        }
        return _results;
      })();
      if (!test.length === path.length) {
        return false;
      }
      for (i = _i = 0, _len = test.length; _i < _len; i = ++_i) {
        matcher = test[i];
        for (k in matcher) {
          v = matcher[k];
          if (!(path[i] != null)) {
            return false;
          }
          if (path[i][k] !== v) {
            return false;
          }
        }
      }
      return true;
    };
    amounts = function() {
      var a, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = arguments.length; _i < _len; _i++) {
        a = arguments[_i];
        _results.push(Amount.from_json(a));
      }
      return _results;
    };
    amounts_text = function() {
      var a, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = arguments.length; _i < _len; _i++) {
        a = arguments[_i];
        _results.push(realias_text(a.to_text_full()));
      }
      return _results;
    };
    check_for_no_redundant_paths = function(alternatives) {
      var alt, existing, existing_paths, i, path, _i, _j, _k, _len, _len1, _len2, _ref2;
      for (i = _i = 0, _len = alternatives.length; _i < _len; i = ++_i) {
        alt = alternatives[i];
        existing_paths = [];
        _ref2 = alt.paths_computed;
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          path = _ref2[_j];
          for (_k = 0, _len2 = existing_paths.length; _k < _len2; _k++) {
            existing = existing_paths[_k];
            assert(!(deep_eq(path, existing)), ("Duplicate path in alternatives[" + i + "]\n") + ("" + (realias_pp(alternatives[0]))));
          }
          existing_paths.push(path);
        }
      }
    };
    return test_alternatives = function(test, actual, error_context) {
      "\n  @test\n    alternatives in shorthand format\n\n  @actual\n    alternatives as returned in a `path_find` response\n    \n  @error_context\n  \n    a function providing a string with extra context to provide to assertion\n    messages\n";

      var a, a_amt, a_amt_txt, an, i, m, matched, p, t, t_amt, t_amt_txt, t_paths, ti, tn, _i, _j, _k, _len, _len1, _len2, _ref2, _ref3, _ref4, _ref5;
      check_for_no_redundant_paths(actual);
      _ref2 = ensure_list(test);
      for (ti = _i = 0, _len = _ref2.length; _i < _len; ti = ++_i) {
        t = _ref2[ti];
        a = actual[ti];
        _ref3 = amounts(t.amount, a.source_amount), t_amt = _ref3[0], a_amt = _ref3[1];
        _ref4 = amounts_text(t_amt, a_amt), t_amt_txt = _ref4[0], a_amt_txt = _ref4[1];
        assert(t_amt.equals(a_amt), ("Expecting alternative[" + ti + "].amount: ") + ("" + t_amt_txt + " == " + a_amt_txt));
        t_paths = ensure_list(t.paths);
        tn = t_paths.length;
        an = a.paths_computed.length;
        assert.equal(tn, an, ("Different number of paths specified for alternative[" + ti + "]") + (", expected: " + (prettyj(t_paths)) + ", ") + ("actual(shorthand): " + (prettyj(create_shorthand(actual)))) + ("actual(verbose): " + (prettyj(a.paths_computed))) + error_context());
        for (i = _j = 0, _len1 = t_paths.length; _j < _len1; i = ++_j) {
          p = t_paths[i];
          matched = false;
          _ref5 = a.paths_computed;
          for (_k = 0, _len2 = _ref5.length; _k < _len2; _k++) {
            m = _ref5[_k];
            if (simple_match_path(p, m, ti, i)) {
              matched = true;
              break;
            }
          }
          assert(matched, ("Can't find a match for path[" + i + "]: " + (prettyj(p)) + " ") + ("amongst " + (prettyj(create_shorthand([a])))) + error_context());
        }
      }
    };
  };

  create_path_test = function(pth) {
    return function(done) {
      var WHAT, error_info, ledger, max_seen, messages, one_message, pf, propagates, self, sent, test_alternatives, updates, _amt, _dst, _src;
      self = this;
      WHAT = self.log_what;
      ledger = self.ledger;
      test_alternatives = test_alternatives_factory(ledger.pretty_json.bind(ledger), ledger.realias_issuer);
      WHAT(("" + pth.title + ": " + pth.src + " sending " + pth.dst + ", ") + ("" + pth.send + ", via " + pth.via));
      one_message = function(f) {
        return self.remote._servers[0].once('before_send_message_for_non_mutators', f);
      };
      sent = "TODO: need to patch ripple-lib";
      one_message(function(m) {
        return sent = m;
      });
      error_info = function(m, more) {
        var info;
        info = {
          path_expected: pth,
          path_find_request: sent,
          path_find_updates: messages
        };
        if (more != null) {
          extend(info, more);
        }
        return ledger.pretty_json(info);
      };
      assert(Amount.from_json(pth.send).is_valid(), "" + pth.send + " is not valid Amount");
      _src = UInt160.json_rewrite(pth.src);
      _dst = UInt160.json_rewrite(pth.dst);
      _amt = Amount.from_json(pth.send);
      pf = self.remote.path_find(_src, _dst, _amt, [
        {
          currency: pth.via
        }
      ]);
      updates = 0;
      max_seen = 0;
      messages = {};
      propagates = propagater(done);
      pf.on("error", propagates(function(m) {
        assert(false, "fail (error): " + (error_info(m)));
        return done();
      }));
      return pf.on("update", propagates(function(m) {
        var alt, alts, test, _i, _len, _ref2;
        _ref2 = m.alternatives;
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          alt = _ref2[_i];
          expand_alternative(alt);
        }
        messages[updates ? "update-" + updates : 'initial-response'] = m;
        updates++;
        assert(m.alternatives.length >= max_seen, "Subsequent path_find update' should never have less " + ("alternatives:\n" + (ledger.pretty_json(messages))));
        max_seen = m.alternatives.length;
        if (updates === 2) {
          if (pth.do_send != null) {
            do_send(ledger.pretty_json.bind(ledger), WHAT, self.remote, pth, messages['update-2'], done);
          }
          if (pth.debug) {
            console.log(ledger.pretty_json(messages));
            console.log(error_info(m));
            console.log(ledger.pretty_json(create_shorthand(m.alternatives)));
          }
          if (pth.alternatives != null) {
            alts = ledger.realias_issuer(JSON.stringify(m.alternatives));
            alts = JSON.parse(alts);
            test = pth.alternatives;
            assert(test.length === alts.length, "Number of `alternatives` specified is different: " + ("" + (error_info(m))));
            if (test.length === alts.length) {
              test_alternatives(pth.alternatives, alts, function() {
                return error_info(m);
              });
            }
          }
          if (pth.n_alternatives != null) {
            assert(pth.n_alternatives === m.alternatives.length, "fail (wrong n_alternatives): " + (error_info(m)));
          }
          if (!(pth.do_send != null)) {
            return done();
          }
        }
      }));
    };
  };

  skip_or_only = function(title, test_or_suite) {
    var endsWith;
    endsWith = function(s, suffix) {
      return ~s.indexOf(suffix, s.length - suffix.length);
    };
    if (endsWith(title, '_only')) {
      return test_or_suite.only;
    } else if (endsWith(title, '_skip')) {
      return test_or_suite.skip;
    } else {
      return test_or_suite;
    }
  };

  definer_factory = function(group, title, path) {
    var test_func;
    path.title = "" + ([group, title].join('.'));
    test_func = skip_or_only(path.title, test);
    return function() {
      return test_func(path.title, create_path_test(path));
    };
  };

  gather_path_definers = function(path_expected) {
    var group, path, subgroup, tests, title;
    tests = [];
    for (group in path_expected) {
      subgroup = path_expected[group];
      for (title in subgroup) {
        path = subgroup[title];
        tests.push(definer_factory(group, title, path));
      }
    }
    return tests;
  };

  suite_factory = function(declaration) {
    return function() {
      var context, definer, _i, _len, _ref2, _results;
      context = null;
      suiteSetup(function(done) {
        context = this;
        this.log_what = function() {};
        return testutils.build_setup().call(this, function() {
          context.ledger = new LedgerState(declaration.ledger, assert, context.remote, config);
          return context.ledger.setup(context.log_what, done);
        });
      });
      suiteTeardown(function(done) {
        return testutils.build_teardown().call(context, done);
      });
      _ref2 = gather_path_definers(declaration.paths_expected);
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        definer = _ref2[_i];
        _results.push(definer());
      }
      return _results;
    };
  };

  define_suites = function(path_finding_cases) {
    var case_name, declaration, suite_func, _results;
    _results = [];
    for (case_name in path_finding_cases) {
      declaration = path_finding_cases[case_name];
      suite_func = skip_or_only(case_name, suite);
      _results.push(suite_func(case_name, suite_factory(declaration)));
    }
    return _results;
  };

  A0 = (new TestAccount('A0')).address;

  assert(A0 === 'rBmhuVAvi372AerwzwERGjhLjqkMmAwxX');

  path_finding_cases_string = fs.readFileSync(__dirname + "/path-tests.json");

  path_finding_cases = JSON.parse(path_finding_cases_string);

  extend(path_finding_cases, {
    "CNY test": {
      paths_expected: {
        BS: {
          P101: {
            src: "SRC",
            dst: "GATEWAY_DST",
            send: "10.1/CNY/GATEWAY_DST",
            via: "XRP",
            n_alternatives: 1
          }
        }
      },
      ledger: {
        accounts: {
          SRC: {
            balance: ["4999.999898"],
            trusts: [],
            offers: []
          },
          GATEWAY_DST: {
            balance: ["10846.168060"],
            trusts: [],
            offers: []
          },
          MONEY_MAKER_1: {
            balance: ["4291.430036"],
            trusts: [],
            offers: []
          },
          MONEY_MAKER_2: {
            balance: ["106839375770", "0.0000000003599/CNY/MONEY_MAKER_1", "137.6852546843001/CNY/GATEWAY_DST"],
            trusts: ["1001/CNY/MONEY_MAKER_1", "1001/CNY/GATEWAY_DST"],
            offers: [["1000000", "1/CNY/GATEWAY_DST"], ["1/CNY/GATEWAY_DST", "1000000"], ["318000/CNY/GATEWAY_DST", "53000000000"], ["209000000", "4.18/CNY/MONEY_MAKER_2"], ["990000/CNY/MONEY_MAKER_1", "10000000000"], ["9990000/CNY/MONEY_MAKER_1", "10000000000"], ["8870000/CNY/GATEWAY_DST", "10000000000"], ["232000000", "5.568/CNY/MONEY_MAKER_2"]]
          },
          A1: {
            balance: ["1240.997150", "0.0000000119761/CNY/MONEY_MAKER_1", "33.047994/CNY/GATEWAY_DST"],
            trusts: ["1000000/CNY/MONEY_MAKER_1", "100000/USD/MONEY_MAKER_1", "10000/BTC/MONEY_MAKER_1", "1000/USD/GATEWAY_DST", "1000/CNY/GATEWAY_DST"],
            offers: []
          },
          A2: {
            balance: ["14115.046893", "209.3081873019994/CNY/MONEY_MAKER_1", "694.6251706504019/CNY/GATEWAY_DST"],
            trusts: ["3000/CNY/MONEY_MAKER_1", "3000/CNY/GATEWAY_DST"],
            offers: [["2000000000", "66.8/CNY/MONEY_MAKER_1"], ["1200000000", "42/CNY/GATEWAY_DST"], ["43.2/CNY/MONEY_MAKER_1", "900000000"]]
          },
          A3: {
            balance: ["512087.883181", "23.617050013581/CNY/MONEY_MAKER_1", "70.999614649799/CNY/GATEWAY_DST"],
            trusts: ["10000/CNY/MONEY_MAKER_1", "10000/CNY/GATEWAY_DST"],
            offers: [["2240/CNY/MONEY_MAKER_1", "50000000000"]]
          }
        }
      }
    },
    "Path Tests (Bitstamp + SnapSwap account holders | liquidity provider with no offers)": {
      ledger: {
        accounts: {
          G1BS: {
            balance: ["1000.0"]
          },
          G2SW: {
            balance: ["1000.0"]
          },
          A1: {
            balance: ["1000.0", "1000/HKD/G1BS"],
            trusts: ["2000/HKD/G1BS"]
          },
          A2: {
            balance: ["1000.0", "1000/HKD/G2SW"],
            trusts: ["2000/HKD/G2SW"]
          },
          M1: {
            balance: ["11000.0", "1200/HKD/G1BS", "5000/HKD/G2SW"],
            trusts: ["100000/HKD/G1BS", "100000/HKD/G2SW"]
          }
        }
      },
      paths_expected: {
        BS: {
          P1: {
            debug: false,
            src: "A1",
            dst: "A2",
            send: "10/HKD/A2",
            via: "HKD",
            n_alternatives: 1
          },
          P2: {
            debug: false,
            src: "A2",
            dst: "A1",
            send: "10/HKD/A1",
            via: "HKD",
            n_alternatives: 1
          },
          P3: {
            debug: false,
            src: "G1BS",
            dst: "A2",
            send: "10/HKD/A2",
            via: "HKD",
            alternatives: [
              {
                amount: "10/HKD/G1BS",
                paths: [["HKD/M1|M1", "HKD/G2SW|G2SW"]]
              }
            ]
          },
          P5: {
            debug: false,
            src: "M1",
            send: "10/HKD/M1",
            dst: "G1BS",
            via: "HKD"
          },
          P4: {
            debug: false,
            src: "G2SW",
            send: "10/HKD/A1",
            dst: "A1",
            via: "HKD",
            alternatives: [
              {
                amount: "10/HKD/G2SW",
                paths: [["HKD/M1|M1", "HKD/G1BS|G1BS"]]
              }
            ]
          }
        }
      }
    },
    "Path Tests #4 (non-XRP to non-XRP, same currency)": {
      ledger: {
        accounts: {
          G1: {
            balance: ["1000.0"]
          },
          G2: {
            balance: ["1000.0"]
          },
          G3: {
            balance: ["1000.0"]
          },
          G4: {
            balance: ["1000.0"]
          },
          A1: {
            balance: ["1000.0", "1000/HKD/G1"],
            trusts: ["2000/HKD/G1"]
          },
          A2: {
            balance: ["1000.0", "1000/HKD/G2"],
            trusts: ["2000/HKD/G2"]
          },
          A3: {
            balance: ["1000.0", "1000/HKD/G1"],
            trusts: ["2000/HKD/G1"]
          },
          A4: {
            balance: ["10000.0"]
          },
          M1: {
            balance: ["11000.0", "1200/HKD/G1", "5000/HKD/G2"],
            trusts: ["100000/HKD/G1", "100000/HKD/G2"],
            offers: [["1000/HKD/G1", "1000/HKD/G2"]]
          },
          M2: {
            balance: ["11000.0", "1200/HKD/G1", "5000/HKD/G2"],
            trusts: ["100000/HKD/G1", "100000/HKD/G2"],
            offers: [["10000.0", "1000/HKD/G2"], ["1000/HKD/G1", "10000.0"]]
          }
        }
      },
      paths_expected: {
        T4: {
          "A) Borrow or repay": {
            comment: 'Source -> Destination (repay source issuer)',
            src: "A1",
            send: "10/HKD/G1",
            dst: "G1",
            via: "HKD",
            alternatives: [
              {
                amount: "10/HKD/A1",
                paths: []
              }
            ]
          },
          "A2) Borrow or repay": {
            comment: 'Source -> Destination (repay destination issuer)',
            src: "A1",
            send: "10/HKD/A1",
            dst: "G1",
            via: "HKD",
            alternatives: [
              {
                amount: "10/HKD/A1",
                paths: []
              }
            ]
          },
          "B) Common gateway": {
            comment: 'Source -> AC -> Destination',
            src: "A1",
            send: "10/HKD/A3",
            dst: "A3",
            via: "HKD",
            alternatives: [
              {
                amount: "10/HKD/A1",
                paths: [["HKD/G1|G1"]]
              }
            ]
          },
          "C) Gateway to gateway": {
            comment: 'Source -> OB -> Destination',
            src: "G1",
            send: "10/HKD/G2",
            dst: "G2",
            via: "HKD",
            debug: false,
            alternatives: [
              {
                amount: "10/HKD/G1",
                paths: [["HKD/M2|M2"], ["HKD/M1|M1"], ["HKD/G2|$"], ["XRP|$", "HKD/G2|$"]]
              }
            ]
          },
          "D) User to unlinked gateway via order book": {
            comment: 'Source -> AC -> OB -> Destination',
            src: "A1",
            send: "10/HKD/G2",
            dst: "G2",
            via: "HKD",
            debug: false,
            alternatives: [
              {
                amount: "10/HKD/A1",
                paths: [["HKD/G1|G1", "HKD/G2|$"], ["HKD/G1|G1", "HKD/M2|M2"], ["HKD/G1|G1", "HKD/M1|M1"], ["HKD/G1|G1", "XRP|$", "HKD/G2|$"]]
              }
            ]
          },
          "I4) XRP bridge": {
            comment: 'Source -> AC -> OB to XRP -> OB from XRP -> AC -> Destination',
            src: "A1",
            send: "10/HKD/A2",
            dst: "A2",
            via: "HKD",
            debug: false,
            alternatives: [
              {
                amount: "10/HKD/A1",
                paths: [["HKD/G1|G1", "HKD/G2|$", "HKD/G2|G2"], ["HKD/G1|G1", "XRP|$", "HKD/G2|$", "HKD/G2|G2"], ["HKD/G1|G1", "HKD/M1|M1", "HKD/G2|G2"], ["HKD/G1|G1", "HKD/M2|M2", "HKD/G2|G2"]]
              }
            ]
          }
        }
      }
    },
    "Path Tests #2 (non-XRP to non-XRP, same currency)": {
      ledger: {
        accounts: {
          G1: {
            balance: ["1000.0"]
          },
          G2: {
            balance: ["1000.0"]
          },
          A1: {
            balance: ["1000.0", "1000/HKD/G1"],
            trusts: ["2000/HKD/G1"]
          },
          A2: {
            balance: ["1000.0", "1000/HKD/G2"],
            trusts: ["2000/HKD/G2"]
          },
          A3: {
            balance: ["1000.0"],
            trusts: ["2000/HKD/A2"]
          },
          M1: {
            balance: ["11000.0", "5000/HKD/G1", "5000/HKD/G2"],
            trusts: ["100000/HKD/G1", "100000/HKD/G2"],
            offers: [["1000/HKD/G1", "1000/HKD/G2"]]
          }
        }
      },
      paths_expected: {
        T4: {
          "E) Gateway to user": {
            ledger: false,
            comment: 'Source -> OB -> AC -> Destination',
            src: "G1",
            send: "10/HKD/A2",
            dst: "A2",
            via: "HKD",
            debug: false,
            alternatives: [
              {
                amount: "10/HKD/G1",
                paths: [["HKD/G2|$", "HKD/G2|G2"], ["HKD/M1|M1", "HKD/G2|G2"]]
              }
            ]
          },
          "F) Different gateways, ripple  _skip": {
            comment: 'Source -> AC -> AC -> Destination'
          },
          "G) Different users of different gateways, ripple  _skip": {
            comment: 'Source -> AC -> AC -> AC -> Destination'
          },
          "H) Different gateways, order book  _skip": {
            comment: 'Source -> AC -> OB -> AC -> Destination'
          },
          "I1) XRP bridge  _skip": {
            comment: 'Source -> OB to XRP -> OB from XRP -> Destination',
            src: "A4",
            send: "10/HKD/G2",
            dst: "G2",
            via: "XRP",
            debug: true
          },
          "I2) XRP bridge  _skip": {
            comment: 'Source -> AC -> OB to XRP -> OB from XRP -> Destination'
          },
          "I3) XRP bridge  _skip": {
            comment: 'Source -> OB to XRP -> OB from XRP -> AC -> Destination'
          }
        }
      }
    }
  });

  define_suites(path_finding_cases);

}).call(this);
