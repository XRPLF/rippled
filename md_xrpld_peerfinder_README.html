<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rippled: PeerFinder</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">rippled
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">PeerFinder </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md558"></a>
Introduction</h1>
<p >The <em>Ripple payment network</em> consists of a collection of <em>peers</em> running the <b>rippled software</b>. Each peer maintains multiple outgoing connections and optional incoming connections to other peers. These connections are made over both the public Internet and private local area networks. This network defines a fully connected directed graph of nodes. Peers send and receive messages to other connected peers. This peer to peer network, layered on top of the public and private Internet, forms an <a href="http://en.wikipedia.org/wiki/Overlay_network"><em>overlay network</em></a>.</p>
<h1><a class="anchor" id="autotoc_md559"></a>
Bootstrapping</h1>
<p >When a peer comes online it needs a set of IP addresses to connect to in order to gain initial entry into the overlay in a process called <em>bootstrapping</em>. Once they have established an initial set of these outbound peer connections, they need to gain additional addresses to establish more outbound peer connections until the desired limit is reached. Furthermore, they need a mechanism to advertise their IP address to new or existing peers in the overlay so they may receive inbound connections up to some desired limit. And finally, they need a mechanism to provide inbound connection requests with an alternate set of IP addresses to try when they have already reached their desired maximum number of inbound connections.</p>
<p >PeerFinder is a self contained module that provides these services, along with some additional overlay network management services such as <em>fixed slots</em> and <em>cluster slots</em>.</p>
<h1><a class="anchor" id="autotoc_md560"></a>
Features</h1>
<p >PeerFinder has these responsibilities</p>
<ul>
<li>Maintain a persistent set of endpoint addresses suitable for bootstrapping into the peer to peer overlay, ranked by relative locally observed utility.</li>
<li>Send and receive protocol messages for discovery of endpoint addresses.</li>
<li>Provide endpoint addresses to new peers that need them.</li>
<li>Maintain connections to a configured set of fixed peers.</li>
<li>Impose limits on the various slots consumed by peer connections.</li>
<li>Initiate outgoing connection attempts to endpoint addresses to maintain the overlay connectivity and fixed peer policies.</li>
<li>Verify the connectivity of neighbors who advertise inbound connection slots.</li>
<li>Prevent duplicate connections and connections to self.</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md562"></a>
Concepts</h1>
<h2><a class="anchor" id="autotoc_md563"></a>
Manager</h2>
<p >The <code>Manager</code> is an application singleton which provides the primary interface to interaction with the PeerFinder.</p>
<h3><a class="anchor" id="autotoc_md564"></a>
Autoconnect</h3>
<p >The Autoconnect feature of PeerFinder automatically establishes outgoing connections using addresses learned from various sources including the configuration file, the result of domain name lookups, and messages received from the overlay itself.</p>
<h3><a class="anchor" id="autotoc_md565"></a>
Callback</h3>
<p >PeerFinder is an isolated code module with few external dependencies. To perform socket specific activities such as establishing outgoing connections or sending messages to connected peers, the Manager is constructed with an abstract interface called the <code>Callback</code>. An instance of this interface performs the actual required operations, making PeerFinder independent of the calling code.</p>
<h3><a class="anchor" id="autotoc_md566"></a>
Config</h3>
<p >The <code>Config</code> structure defines the operational parameters of the PeerFinder. Some values come from the configuration file while others are calculated via tuned heuristics. The fields are as follows:</p>
<ul>
<li><p class="startli"><code>autoConnect</code></p>
<p class="startli">A flag indicating whether or not the Autoconnect feature is enabled.</p>
</li>
<li><p class="startli"><code>wantIncoming</code></p>
<p class="startli">A flag indicating whether or not the peer desires inbound connections. When this flag is turned off, a peer will not advertise itself in Endpoint messages.</p>
</li>
<li><p class="startli"><code>listeningPort</code></p>
<p class="startli">The port number to use when creating the listening socket for peer connections.</p>
</li>
<li><p class="startli"><code>maxPeers</code></p>
<p class="startli">The largest number of active peer connections to allow. This includes inbound and outbound connections, but excludes fixed and cluster peers. There is an implementation defined floor on this value.</p>
</li>
<li><p class="startli"><code>outPeers</code></p>
<p class="startli">The number of automatic outbound connections that PeerFinder will maintain when the Autoconnect feature is enabled. The value is computed with fractional precision as an implementation defined percentage of <code>maxPeers</code> subject to an implementation defined floor. An instance of the PeerFinder rounds the fractional part up or down using a uniform random number generated at program startup. This allows the outdegree of the overlay network to be controlled with fractional precision, ensuring that all inbound network connection slots are not consumed (which would make it difficult for new participants to enter the network).</p>
</li>
</ul>
<p >Here's an example of how the network might be structured with a fractional value for outPeers:</p>
<p >**(Need example here)**</p>
<h3><a class="anchor" id="autotoc_md567"></a>
Livecache</h3>
<p >The Livecache holds relayed IP addresses that have been received recently in the form of Endpoint messages via the peer to peer overlay. A peer periodically broadcasts the Endpoint message to its neighbors when it has open inbound connection slots. Peers store these messages in the Livecache and periodically forward their neighbors a handful of random entries from their Livecache, with an incremented hop count for each forwarded entry.</p>
<p >The algorithm for sending a neighbor a set of Endpoint messages chooses evenly from all available hop counts on each send. This ensures that each peer will see some entries with the farthest hops at each iteration. The result is to expand a peer's horizon with respect to which overlay endpoints are visible. This is designed to force the overlay to become highly connected and reduce the network diameter with each connection establishment.</p>
<p >When a peer receives an Endpoint message that originates from a neighbor (identified by a hop count of zero) for the first time, it performs an incoming connection test on that neighbor by initiating an outgoing connection to the remote IP address as seen on the connection combined with the port advertised in the Endpoint message. If the test fails, then the peer considers its neighbor firewalled (intentionally or due to misconfiguration) and not forward neighbor endpoint in Endpoint messages. This prevents poor quality unconnectible addresses from landing in the caches. If the incoming connection test passes, then the peer fills in the Endpoint message with the remote address as seen on the connection before storing it in its cache and forwarding it to other peers. This relieves the neighbor from the responsibility of knowing its own IP address before it can start receiving incoming connections.</p>
<p >Livecache entries expire quickly. Since a peer stops advertising itself when it no longer has available inbound slots, its address will shortly after stop being handed out by other peers. Livecache entries are very likely to result in both a successful connection establishment and the acquisition of an active outbound slot. Compare this with Bootcache addresses, which are very likely to be connectible but unlikely to have an open slot.</p>
<p >Because entries in the Livecache are ephemeral, they are not persisted across launches in the database. The Livecache is continually updated and expired as Endpoint messages are received from the overlay over time.</p>
<h3><a class="anchor" id="autotoc_md568"></a>
Bootcache</h3>
<p >The <code>Bootcache</code> stores IP addresses useful for gaining initial connections. Each address is associated with the following metadata:</p>
<ul>
<li><p class="startli"><b>Valence</b></p>
<p class="startli">A signed integer which represents the number of successful consecutive connection attempts when positive, and the number of failed consecutive connection attempts when negative. If an outgoing connection attempt to the corresponding IP address fails to complete the handshake the valence is reset to negative one. This harsh penalty is intended to prevent popular servers from forever remaining top ranked in all peer databases.</p>
</li>
</ul>
<p >When choosing addresses from the boot cache for the purpose of establishing outgoing connections, addresses are ranked in decreasing order of valence. The Bootcache is persistent. Entries are periodically inserted and updated in the corresponding SQLite database during program operation. When <b>rippled</b> is launched, the existing Bootcache database data is accessed and loaded to accelerate the bootstrap process.</p>
<p >Desirable entries in the Bootcache are addresses for servers which are known to have high uptimes, and for which connection attempts usually succeed. However, these servers do not necessarily have available inbound connection slots. However, it is assured that these servers will have a well populated Livecache since they will have moved towards the core of the overlay over their high uptime. When a connected server is full it will return a handful of new addresses from its Livecache and gracefully close the connection. Addresses from the Livecache are highly likely to have inbound connection slots and be connectible.</p>
<p >For security, all information that contributes to the ranking of Bootcache entries is observed locally. PeerFinder never trusts external sources of information.</p>
<h3><a class="anchor" id="autotoc_md569"></a>
Slot</h3>
<p >Each TCP/IP socket that can participate in the peer to peer overlay occupies a slot. Slots have properties and state associated with them:</p>
<h4><a class="anchor" id="autotoc_md570"></a>
State (Slot)</h4>
<p >The slot state represents the current stage of the connection as it passes through the business logic for establishing peer connections.</p>
<ul>
<li><p class="startli"><code>accept</code></p>
<p class="startli">The accept state is an initial state resulting from accepting an incoming connection request on a listening socket. The remote IP address and port are known, and a handshake is expected next.</p>
</li>
<li><p class="startli"><code>connect</code></p>
<p class="startli">The connect state is an initial state used when actively establishing outbound connection attempts. The desired remote IP address and port are known.</p>
</li>
<li><p class="startli"><code>connected</code></p>
<p class="startli">When an outbound connection attempt succeeds, it moves to the connected state. The handshake is initiated but not completed.</p>
</li>
<li><p class="startli"><code>active</code></p>
<p class="startli">The state becomes Active when a connection in either the Accepted or Connected state completes the handshake process, and a slot is available based on the properties. If no slot is available when the handshake completes, the socket is gracefully closed.</p>
</li>
<li><p class="startli"><code>closing</code></p>
<p class="startli">The Closing state represents a connected socket in the process of being gracefully closed.</p>
</li>
</ul>
<h4><a class="anchor" id="autotoc_md571"></a>
Properties (Slot)</h4>
<p >Slot properties may be combined and are not mutually exclusive.</p>
<ul>
<li><p class="startli"><b>Inbound</b></p>
<p class="startli">An inbound slot is the condition of a socket which has accepted an incoming connection request. A connection which is not inbound is by definition outbound.</p>
</li>
<li><p class="startli"><b>Fixed</b></p>
<p class="startli">A fixed slot is a desired connection to a known peer identified by IP address, usually entered manually in the configuration file. For the purpose of establishing outbound connections, the peer also has an associated port number although only the IP address is checked to determine if the fixed peer is already connected. Fixed slots do not count towards connection limits.</p>
</li>
<li><p class="startli"><b>Cluster</b></p>
<p class="startli">A cluster slot is a connection which has completed the handshake stage, whose public key matches a known public key usually entered manually in the configuration file or learned through overlay messages from other trusted peers. Cluster slots do not count towards connection limits.</p>
</li>
<li><p class="startli"><b>Superpeer</b> (forthcoming)</p>
<p class="startli">A superpeer slot is a connection to a peer which can accept incoming connections, meets certain resource availaibility requirements (such as bandwidth, CPU, and storage capacity), and operates full duplex in the overlay. Connections which are not superpeers are by definition leaves. A leaf slot is a connection to a peer which does not route overlay messages to other peers, and operates in a partial half duplex fashion in the overlay.</p>
</li>
</ul>
<h4><a class="anchor" id="autotoc_md572"></a>
Fixed Slots</h4>
<p >Fixed slots are identified by IP address and set up during the initialization of the Manager, usually from the configuration file. The Logic will always make outgoing connection attempts to each fixed slot which is not currently connected. If we receive an inbound connection from an endpoint whose address portion (without port) matches a fixed slot address, we consider the fixed slot to be connected.</p>
<h4><a class="anchor" id="autotoc_md573"></a>
Cluster Slots</h4>
<p >Cluster slots are identified by the public key and set up during the initialization of the manager or discovered upon receipt of messages in the overlay from trusted connections.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md575"></a>
Algorithms</h1>
<h2><a class="anchor" id="autotoc_md576"></a>
Connection Strategy</h2>
<p >The <em>Connection Strategy</em> applies the configuration settings to establish desired outbound connections. It runs periodically and progresses through a series of stages, remaining in each stage until a condition is met</p>
<h3><a class="anchor" id="autotoc_md577"></a>
Stage 1: Fixed Slots</h3>
<p >This stage is invoked when the number of active fixed connections is below the number of fixed connections specified in the configuration, and one of the following is true:</p>
<ul>
<li>There are eligible fixed addresses to try</li>
<li>Any outbound connection attempts are in progress</li>
</ul>
<p >Each fixed address is associated with a retry timer. On a fixed connection failure, the timer is reset so that the address is not tried for some amount of time, which increases according to a scheduled sequence up to some maximum which is currently set to approximately one hour between retries. A fixed address is considered eligible if we are not currently connected or attempting the address, and its retry timer has expired.</p>
<p >The PeerFinder makes its best effort to become fully connected to the fixed addresses specified in the configuration file before moving on to establish outgoing connections to foreign peers. This security feature helps rippled establish itself with a trusted set of peers first before accepting untrusted data from the network.</p>
<h3><a class="anchor" id="autotoc_md578"></a>
Stage 2: Livecache</h3>
<p >The Livecache is invoked when Stage 1 is not active, autoconnect is enabled, and the number of active outbound connections is below the number desired. The stage remains active while:</p>
<ul>
<li>The Livecache has addresses to try</li>
<li>Any outbound connection attempts are in progress</li>
</ul>
<p >PeerFinder makes its best effort to exhaust addresses in the Livecache before moving on to the Bootcache, because Livecache addresses are highly likely to be connectible (since they are known to have been online within the last minute), and highly likely to have an open slot for an incoming connection (because peers only advertise themselves in the Livecache when they have open slots).</p>
<h3><a class="anchor" id="autotoc_md579"></a>
Stage 3: Bootcache</h3>
<p >The Bootcache is invoked when Stage 1 and Stage 2 are not active, autoconnect is enabled, and the number of active outbound connections is below the number desired. The stage remains active while:</p>
<ul>
<li>There are addresses in the cache that have not been tried recently.</li>
</ul>
<p >Entries in the Bootcache are ranked, with highly connectible addresses preferred over others. Connection attempts to Bootcache addresses are very likely to succeed but unlikely to produce an active connection since the peers likely do not have open slots. Before the remote peer closes the connection it will send a handful of addresses from its Livecache to help the new peer coming online obtain connections.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md581"></a>
References</h1>
<p >Much of the work in PeerFinder was inspired by earlier work in Gnutella:</p>
<p ><a href="http://rfc-gnutella.sourceforge.net/src/pong-caching.html">Revised Gnutella Ping Pong Scheme</a><br  />
 <em>By Christopher Rohrs and Vincent Falco</em></p>
<p ><a href="http://rfc-gnutella.sourceforge.net/src/rfc-0_6-draft.html">Gnutella 0.6 Protocol:</a> Sections:</p><ul>
<li>2.2.2 Ping (0x00)</li>
<li>2.2.3 Pong (0x01)</li>
<li>2.2.4 Use of Ping and Pong messages</li>
<li>2.2.4.1 A simple pong caching scheme</li>
<li>2.2.4.2 Other pong caching schemes </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
